running mutation 1
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_1. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;

lhs p__br_tmp00 rhs 1==1&&!(!(!(p_src==20&&1==1)))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;

lhs p__br_tmp10 rhs 1==1&&!(p_src==20&&1==1)&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;

lhs p__br_tmp20 rhs 1==1&&p_dst==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p_established00', 'p_drop']
p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;

lhs p__br_tmp30 rhs 1==1&&!(!(p_src==20&&1==1))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;

lhs p__br_tmp40 rhs 1==1&&p_src==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7f463c4ebbb0>, 'write': <dependencyGraph.Statement object at 0x7f463b4c8670>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7f463c4ebbb0>, 'write': <dependencyGraph.Statement object at 0x7f463b4c8670>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  10
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1 stmts len 1
p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
SCC 4
v p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1 stmts len 1
p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;
SCC 5
v p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1 stmts len 1
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
SCC 6
v p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1 stmts len 1
p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;
SCC 7
v p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1 stmts len 1
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f463b4c89d0>, <dependencyGraph.Codelet object at 0x7f463b4c8ac0>, <dependencyGraph.Codelet object at 0x7f463b4c8a30>, <dependencyGraph.Codelet object at 0x7f463b4c80a0>, <dependencyGraph.Codelet object at 0x7f463b4c8af0>, <dependencyGraph.Codelet object at 0x7f463b4c8bb0>, <dependencyGraph.Codelet object at 0x7f463b4c8c10>, <dependencyGraph.Codelet object at 0x7f463b4c8c70>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f463b4c8ac0>}
total number of nodes created:  8
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  8
total number of nodes created:  8
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_1_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_1_out
Stored read, write flank variables
{'p_established01', 'p_established00'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  8
number of nodes in comp_graph:  8
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;', 'p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;', 'p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;', 'p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;', 'p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p_established00', 'p__br_tmp00', 'p__br_tmp10', 'p_drop', 'p__br_tmp20']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p_established00', 'p__br_tmp00', 'p__br_tmp10', 'p_drop', 'p__br_tmp20']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp30', 'p_drop', 'p__br_tmp20', 'p__br_tmp40']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp30', 'p_drop', 'p__br_tmp20', 'p__br_tmp40']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['p_established00', 'established']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 exclude_read_write_flanks: successor inputs:  {'p_established00', 'p__br_tmp10', 'p__br_tmp00', 'p_drop', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
redundant outputs []
adj_inputs ['p_established00', 'p__br_tmp00', 'p__br_tmp10', 'p_drop', 'p__br_tmp20']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;
redundant outputs []
adj_inputs ['p_established00', 'p__br_tmp00', 'p__br_tmp10', 'p_drop', 'p__br_tmp20']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'established', 'p_src', 'p__br_tmp40']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p_src', 'p__br_tmp40']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
redundant outputs []
adj_inputs ['p_established00', 'p__br_tmp00', 'p__br_tmp10', 'p_drop', 'p__br_tmp20']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'p__br_tmp30', 'established', 'p_src']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp30', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_dst', 'p_src']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p_established00', 'p__br_tmp10', 'p__br_tmp00', 'p_drop', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p_established00', 'p__br_tmp10', 'p__br_tmp00', 'p_drop', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;
 * recursive_merge: node ::  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp30', 'p__br_tmp00', 'established', 'p__br_tmp40'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp30', 'p__br_tmp00', 'established', 'p__br_tmp40'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p_established00', 'p__br_tmp00', 'p__br_tmp10', 'p__br_tmp30', 'p_drop', 'established', 'p__br_tmp20', 'p__br_tmp40'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp30', 'p_src', 'p__br_tmp40']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p_src', 'p__br_tmp40']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp30', 'p_src']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p_array_index0', 'p__br_tmp00', 'p_drop0', 'p__br_tmp30', 'p__br_tmp40'}
{'p_array_index0', 'p__br_tmp00', 'p_drop0', 'p__br_tmp30', 'p__br_tmp40'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = 1==1&&!(!(!(p_src==20&&1==1)))&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp30 = 1==1&&!(!(p_src==20&&1==1))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = 1==1&&!(p_src==20&&1==1)&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 ~~~| state var:  ['established']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 problematic inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 problematic state vars:  ['established']
preprocessor time:
running mutation 2
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_2. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;

lhs p__br_tmp00 rhs !(!(1==1&&!(p_src==20&&1==1)))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;

lhs p__br_tmp10 rhs !(p_src==20&&1==1)&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;

lhs p__br_tmp20 rhs 1==1&&p_dst==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p_established00', 'p_drop']
p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;

lhs p__br_tmp30 rhs !(1==1&&!(p_src==20&&1==1))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;

lhs p__br_tmp40 rhs 1==1&&p_src==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7fd890fe8bb0>, 'write': <dependencyGraph.Statement object at 0x7fd88ffc5670>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7fd890fe8bb0>, 'write': <dependencyGraph.Statement object at 0x7fd88ffc5670>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  10
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1 stmts len 1
p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
SCC 4
v p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1 stmts len 1
p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;
SCC 5
v p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1 stmts len 1
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
SCC 6
v p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1 stmts len 1
p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;
SCC 7
v p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1 stmts len 1
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7fd88ffc59d0>, <dependencyGraph.Codelet object at 0x7fd88ffc5ac0>, <dependencyGraph.Codelet object at 0x7fd88ffc5a30>, <dependencyGraph.Codelet object at 0x7fd88ffc50a0>, <dependencyGraph.Codelet object at 0x7fd88ffc5af0>, <dependencyGraph.Codelet object at 0x7fd88ffc5bb0>, <dependencyGraph.Codelet object at 0x7fd88ffc5c10>, <dependencyGraph.Codelet object at 0x7fd88ffc5c70>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7fd88ffc5ac0>}
total number of nodes created:  8
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  8
total number of nodes created:  8
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_2_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_2_out
Stored read, write flank variables
{'p_established01', 'p_established00'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  8
number of nodes in comp_graph:  8
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;', 'p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;', 'p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;', 'p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;', 'p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p__br_tmp00', 'p_established00', 'p_drop', 'p__br_tmp10', 'p__br_tmp20']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p__br_tmp00', 'p_established00', 'p_drop', 'p__br_tmp10', 'p__br_tmp20']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp00', 'p__br_tmp30', 'p_drop', 'p__br_tmp40', 'p__br_tmp10', 'p__br_tmp20']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp30', 'p_drop', 'p__br_tmp40', 'p__br_tmp10', 'p__br_tmp20']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['established', 'p_established00']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p_established00', 'p_drop', 'p__br_tmp10', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp00', 'p_established00', 'p_drop', 'p__br_tmp10', 'p__br_tmp20']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp00', 'p_established00', 'p_drop', 'p__br_tmp10', 'p__br_tmp20']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'p_src', 'established', 'p__br_tmp40']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p_src', 'p__br_tmp40']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp00', 'p_established00', 'p_drop', 'p__br_tmp10', 'p__br_tmp20']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'p_src', 'p__br_tmp30', 'established']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p_src', 'p__br_tmp30']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_src', 'p_dst']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p_established00', 'p_drop', 'p__br_tmp10', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p_established00', 'p_drop', 'p__br_tmp10', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'established', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'established', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p_established00', 'p__br_tmp30', 'p_drop', 'established', 'p__br_tmp40', 'p__br_tmp10', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p_src', 'p__br_tmp30', 'p__br_tmp40']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p_src', 'p__br_tmp40']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p_src', 'p__br_tmp30']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p__br_tmp00', 'p_drop0', 'p__br_tmp30', 'p_array_index0', 'p__br_tmp40'}
{'p__br_tmp00', 'p_drop0', 'p__br_tmp30', 'p_array_index0', 'p__br_tmp40'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp30 = !(1==1&&!(p_src==20&&1==1))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = !(p_src==20&&1==1)&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 ~~~| state var:  ['established']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 problematic inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 problematic state vars:  ['established']
preprocessor time:
running mutation 3
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_3. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);

lhs p__br_tmp00 rhs !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1)
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;

lhs p__br_tmp10 rhs !(!(1==1&&!(p_src==20&&1==1)))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;

lhs p__br_tmp20 rhs 1==1&&!(p_src==20&&1==1)&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;

lhs p__br_tmp30 rhs 1==1&&1==1&&p_dst==20&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p__br_tmp30', 'p_established00', 'p_drop']
p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;

lhs p__br_tmp40 rhs !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;

lhs p__br_tmp50 rhs !(1==1&&!(p_src==20&&1==1))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;

lhs p__br_tmp60 rhs 1==1&&1==1&&p_src==20&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp40', 'p__br_tmp50', 'p__br_tmp60', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);
RAW p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1); p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1); p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);
RAW p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);
RAW p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);
RAW p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7f7f9bca3bb0>, 'write': <dependencyGraph.Statement object at 0x7f7f9ac817c0>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7f7f9bca3bb0>, 'write': <dependencyGraph.Statement object at 0x7f7f9ac817c0>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  12
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1) stmts len 1
p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
SCC 4
v p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1 stmts len 1
p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
SCC 5
v p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1 stmts len 1
p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;
SCC 6
v p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1 stmts len 1
p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;
SCC 7
v p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1 stmts len 1
p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;
SCC 8
v p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1 stmts len 1
p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;
SCC 9
v p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1 stmts len 1
p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f7f9ac81a90>, <dependencyGraph.Codelet object at 0x7f7f9ac81a60>, <dependencyGraph.Codelet object at 0x7f7f9ac81b50>, <dependencyGraph.Codelet object at 0x7f7f9ac81b80>, <dependencyGraph.Codelet object at 0x7f7f9ac81c10>, <dependencyGraph.Codelet object at 0x7f7f9ac81cd0>, <dependencyGraph.Codelet object at 0x7f7f9ac81d30>, <dependencyGraph.Codelet object at 0x7f7f9ac81d90>, <dependencyGraph.Codelet object at 0x7f7f9ac81df0>, <dependencyGraph.Codelet object at 0x7f7f9ac81e50>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;
p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;
p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;
p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;
p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f7f9ac81a60>}
total number of nodes created:  10
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  10
total number of nodes created:  10
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_3_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_3_out
Stored read, write flank variables
{'p_established01', 'p_established00'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  10
number of nodes in comp_graph:  10
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;', 'p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;', 'p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;', 'p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;', 'p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;', 'p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;', 'p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p__br_tmp20', 'p_drop', 'p__br_tmp40', 'p__br_tmp60']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p__br_tmp20', 'p_drop', 'p__br_tmp40', 'p__br_tmp60']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['established', 'p_established00']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp50', 'p__br_tmp60']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p_src', 'established', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp60']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p_src', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp60']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p_src', 'established', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp60']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p_src', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp60']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p_src', 'established', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp40']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p_src', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp40']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_src', 'p_dst']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;
 * recursive_merge: node ::  p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;
 * recursive_merge: node ::  p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
 * recursive_merge: node ::  p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;
 node outputs:  ['p__br_tmp60']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'established', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp40', 'p__br_tmp60'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;
 * recursive_merge: node ::  p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;
 node outputs:  ['p__br_tmp50']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'established', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp40', 'p__br_tmp60'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;
 * recursive_merge: node ::  p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'established', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp40', 'p__br_tmp60'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'established', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p__br_tmp20', 'p_established00', 'p_drop', 'p__br_tmp40', 'p__br_tmp60'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
 --- cannot fold. too many stateless inputs:  ['p_src', 'p__br_tmp50', 'p__br_tmp40', 'p__br_tmp60']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p_src', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp60']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p_src', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp60']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;
 --- cannot fold. too many stateless inputs:  ['p_src', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp40']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p__br_tmp00', 'p__br_tmp50', 'p_drop0', 'p_array_index0', 'p__br_tmp40', 'p__br_tmp60'}
{'p__br_tmp00', 'p__br_tmp50', 'p_drop0', 'p_array_index0', 'p__br_tmp40', 'p__br_tmp60'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = !(!(!(!(1==1&&!(p_src==20&&1==1))))&&1==1);
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp40 = !(!(!(1==1&&!(p_src==20&&1==1))))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp50 = !(1==1&&!(p_src==20&&1==1))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp60 = 1==1&&1==1&&p_src==20&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = !(!(1==1&&!(p_src==20&&1==1)))&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = 1==1&&!(p_src==20&&1==1)&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp30 = 1==1&&1==1&&p_dst==20&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)) ? (p_established00==0) : (p_drop);
Error: stateful update does not fit in the stateful ALU.
node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp40)&&(p__br_tmp50)&&(p__br_tmp60)) ? (1) : (p_established00); established = p_established01;
inputs:  ['established', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp50', 'p__br_tmp60']
outputs:  ['established', 'p_established00']
preprocessor time:
running mutation 4
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_4. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;

lhs p__br_tmp00 rhs 1==1&&!(!(!(p_src==20))&&1==1)&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;

lhs p__br_tmp10 rhs 1==1&&!(p_src==20)&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;

lhs p__br_tmp20 rhs 1==1&&p_dst==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p_established00', 'p_drop']
p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;

lhs p__br_tmp30 rhs 1==1&&!(!(p_src==20))&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;

lhs p__br_tmp40 rhs 1==1&&p_src==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7fdca6017bb0>, 'write': <dependencyGraph.Statement object at 0x7fdca4ff4670>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7fdca6017bb0>, 'write': <dependencyGraph.Statement object at 0x7fdca4ff4670>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  10
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1 stmts len 1
p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
SCC 4
v p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1 stmts len 1
p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;
SCC 5
v p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1 stmts len 1
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
SCC 6
v p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1 stmts len 1
p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;
SCC 7
v p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1 stmts len 1
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7fdca4ff49d0>, <dependencyGraph.Codelet object at 0x7fdca4ff4ac0>, <dependencyGraph.Codelet object at 0x7fdca4ff4a30>, <dependencyGraph.Codelet object at 0x7fdca4ff4070>, <dependencyGraph.Codelet object at 0x7fdca4ff4af0>, <dependencyGraph.Codelet object at 0x7fdca4ff4bb0>, <dependencyGraph.Codelet object at 0x7fdca4ff4c10>, <dependencyGraph.Codelet object at 0x7fdca4ff4c70>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7fdca4ff4ac0>}
total number of nodes created:  8
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  8
total number of nodes created:  8
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_4_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_4_out
Stored read, write flank variables
{'p_established00', 'p_established01'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  8
number of nodes in comp_graph:  8
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;', 'p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;', 'p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;', 'p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;', 'p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_established00']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_established00']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['established', 'p_established00']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 exclude_read_write_flanks: successor inputs:  {'p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_established00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
redundant outputs []
adj_inputs ['p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_established00']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;
redundant outputs []
adj_inputs ['p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_established00']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'p__br_tmp40', 'established', 'p_src']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp40', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
redundant outputs []
adj_inputs ['p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_established00']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'established', 'p__br_tmp30', 'p_src']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp30', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_src', 'p_dst']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_established00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_established00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'established', 'p__br_tmp30', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'established', 'p__br_tmp30', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p_drop', 'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp40', 'established', 'p__br_tmp30', 'p__br_tmp20', 'p_established00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp40', 'p__br_tmp30', 'p_src']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp40', 'p_src']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp30', 'p_src']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p_array_index0', 'p_drop0', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp30'}
{'p_array_index0', 'p_drop0', 'p__br_tmp00', 'p__br_tmp40', 'p__br_tmp30'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = 1==1&&!(!(!(p_src==20))&&1==1)&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 ~~~| state var:  ['established']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 problematic inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 problematic state vars:  ['established']
preprocessor time:
running mutation 5
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_5. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);

lhs p__br_tmp00 rhs !(!(!(1==1&&p_src==20))&&1==1&&1==1)
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;

lhs p__br_tmp10 rhs !(1==1&&p_src==20)&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;

lhs p__br_tmp20 rhs 1==1&&p_dst==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p_established00', 'p_drop']
p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;

lhs p__br_tmp30 rhs !(!(1==1&&p_src==20))&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;

lhs p__br_tmp40 rhs 1==1&&p_src==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1); p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1); p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7fb0fdb6dbb0>, 'write': <dependencyGraph.Statement object at 0x7fb0fcb4a670>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7fb0fdb6dbb0>, 'write': <dependencyGraph.Statement object at 0x7fb0fcb4a670>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  10
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1) stmts len 1
p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
SCC 4
v p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1 stmts len 1
p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;
SCC 5
v p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1 stmts len 1
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
SCC 6
v p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1 stmts len 1
p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;
SCC 7
v p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1 stmts len 1
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7fb0fcb4a9d0>, <dependencyGraph.Codelet object at 0x7fb0fcb4aac0>, <dependencyGraph.Codelet object at 0x7fb0fcb4aa30>, <dependencyGraph.Codelet object at 0x7fb0fcb4a070>, <dependencyGraph.Codelet object at 0x7fb0fcb4aaf0>, <dependencyGraph.Codelet object at 0x7fb0fcb4abb0>, <dependencyGraph.Codelet object at 0x7fb0fcb4ac10>, <dependencyGraph.Codelet object at 0x7fb0fcb4ac70>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;
p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;
p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7fb0fcb4aac0>}
total number of nodes created:  8
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  8
total number of nodes created:  8
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_5_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_5_out
Stored read, write flank variables
{'p_established00', 'p_established01'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  8
number of nodes in comp_graph:  8
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;', 'p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;', 'p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;', 'p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;', 'p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp10', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp00', 'p__br_tmp20', 'p_drop']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp10', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp00', 'p__br_tmp20', 'p_drop']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['p_established00', 'established']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp40', 'p__br_tmp00', 'p_src', 'established']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp40', 'p__br_tmp00', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp30', 'p__br_tmp00', 'p_src', 'established']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp30', 'p__br_tmp00', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_dst', 'p_src']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'established', 'p__br_tmp30', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'established', 'p__br_tmp30', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp00', 'p__br_tmp20', 'p_drop', 'p_established00', 'established'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
 --- cannot fold. too many stateless inputs:  ['p__br_tmp40', 'p__br_tmp30', 'p_src']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp40', 'p__br_tmp00', 'p_src']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp30', 'p__br_tmp00', 'p_src']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p_drop0', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp00', 'p_array_index0'}
{'p_drop0', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp00', 'p_array_index0'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = !(!(!(1==1&&p_src==20))&&1==1&&1==1);
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp30 = !(!(1==1&&p_src==20))&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp40 = 1==1&&p_src==20&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = !(1==1&&p_src==20)&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = 1==1&&p_dst==20&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 ~~~| state var:  ['established']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 problematic inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 problematic state vars:  ['established']
preprocessor time:
running mutation 6
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_6. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;

lhs p__br_tmp00 rhs !(!(!(!(!(!(!(p_src==20)))))))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;

lhs p__br_tmp10 rhs !(!(!(!(!(p_src==20)))))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = !(!(!(p_src==20)))&&1==1;

lhs p__br_tmp20 rhs !(!(!(p_src==20)))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = !(!(!(p_src==20)))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp30 = !(p_src==20)&&1==1;

lhs p__br_tmp30 rhs !(p_src==20)&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = !(p_src==20)&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp40 = p_dst==20&&1==1;

lhs p__br_tmp40 rhs p_dst==20&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = p_dst==20&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p__br_tmp30', 'p__br_tmp40', 'p_established00', 'p_drop']
p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;

lhs p__br_tmp50 rhs !(!(!(!(!(!(p_src==20))))))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;

lhs p__br_tmp60 rhs !(!(!(!(p_src==20))))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp70 = !(!(p_src==20))&&1==1;

lhs p__br_tmp70 rhs !(!(p_src==20))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp70 = !(!(p_src==20))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp80 = p_src==20&&1==1;

lhs p__br_tmp80 rhs p_src==20&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp80 = p_src==20&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp50', 'p__br_tmp60', 'p__br_tmp70', 'p__br_tmp80', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);
RAW p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);
RAW p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = !(!(!(p_src==20)))&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp30 = !(p_src==20)&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp40 = p_dst==20&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);
RAW p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);
RAW p__br_tmp70 = !(!(p_src==20))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);
RAW p__br_tmp80 = p_src==20&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7f052ca3abb0>, 'write': <dependencyGraph.Statement object at 0x7f052ba187c0>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7f052ca3abb0>, 'write': <dependencyGraph.Statement object at 0x7f052ba187c0>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  14
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1 stmts len 1
p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
SCC 4
v p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1 stmts len 1
p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;
SCC 5
v p__br_tmp20 = !(!(!(p_src==20)))&&1==1 stmts len 1
p__br_tmp20 = !(!(!(p_src==20)))&&1==1;
SCC 6
v p__br_tmp30 = !(p_src==20)&&1==1 stmts len 1
p__br_tmp30 = !(p_src==20)&&1==1;
SCC 7
v p__br_tmp40 = p_dst==20&&1==1 stmts len 1
p__br_tmp40 = p_dst==20&&1==1;
SCC 8
v p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1 stmts len 1
p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;
SCC 9
v p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1 stmts len 1
p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;
SCC 10
v p__br_tmp70 = !(!(p_src==20))&&1==1 stmts len 1
p__br_tmp70 = !(!(p_src==20))&&1==1;
SCC 11
v p__br_tmp80 = p_src==20&&1==1 stmts len 1
p__br_tmp80 = p_src==20&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f052ba18c10>, <dependencyGraph.Codelet object at 0x7f052ba18d00>, <dependencyGraph.Codelet object at 0x7f052ba18df0>, <dependencyGraph.Codelet object at 0x7f052ba18e50>, <dependencyGraph.Codelet object at 0x7f052ba18eb0>, <dependencyGraph.Codelet object at 0x7f052ba18f10>, <dependencyGraph.Codelet object at 0x7f052ba18f70>, <dependencyGraph.Codelet object at 0x7f052ba18fd0>, <dependencyGraph.Codelet object at 0x7f052ba18dc0>, <dependencyGraph.Codelet object at 0x7f052ba18fa0>, <dependencyGraph.Codelet object at 0x7f052ba18430>, <dependencyGraph.Codelet object at 0x7f052ba18d60>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;
p__br_tmp20 = !(!(!(p_src==20)))&&1==1;
p__br_tmp30 = !(p_src==20)&&1==1;
p__br_tmp40 = p_dst==20&&1==1;
p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;
p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;
p__br_tmp70 = !(!(p_src==20))&&1==1;
p__br_tmp80 = p_src==20&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f052ba18d00>}
total number of nodes created:  12
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  12
total number of nodes created:  12
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_6_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_6_out
Stored read, write flank variables
{'p_established01', 'p_established00'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  12
number of nodes in comp_graph:  12
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp40 = p_dst==20&&1==1;', 'p__br_tmp30 = !(p_src==20)&&1==1;', 'p__br_tmp20 = !(!(!(p_src==20)))&&1==1;', 'p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;', 'p__br_tmp80 = p_src==20&&1==1;', 'p__br_tmp70 = !(!(p_src==20))&&1==1;', 'p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;', 'p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;', 'p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp60', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp80', 'p__br_tmp20', 'p_drop', 'p__br_tmp50', 'p__br_tmp70']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp60', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp80', 'p__br_tmp20', 'p_drop', 'p__br_tmp50', 'p__br_tmp70']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp20 = !(!(!(p_src==20)))&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp30 = !(p_src==20)&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp40 = p_dst==20&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['p_established00', 'established']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp60', 'p__br_tmp70', 'p__br_tmp80']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp80', 'established', 'p__br_tmp70']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp80', 'p__br_tmp70']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'p_src', 'p__br_tmp80', 'p__br_tmp50', 'established', 'p__br_tmp70']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p_src', 'p__br_tmp80', 'p__br_tmp50', 'p__br_tmp70']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp70 = !(!(p_src==20))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp80', 'p__br_tmp50', 'established']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp80', 'p__br_tmp50']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp80 = p_src==20&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp50', 'established', 'p__br_tmp70']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp50', 'p__br_tmp70']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_dst', 'p_src']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp40 = p_dst==20&&1==1;
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = p_dst==20&&1==1;
 * recursive_merge: node ::  p__br_tmp30 = !(p_src==20)&&1==1;
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = !(p_src==20)&&1==1;
 * recursive_merge: node ::  p__br_tmp20 = !(!(!(p_src==20)))&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = !(!(!(p_src==20)))&&1==1;
 * recursive_merge: node ::  p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp20', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;
 * recursive_merge: node ::  p__br_tmp80 = p_src==20&&1==1;
 node outputs:  ['p__br_tmp80']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp60', 'p__br_tmp80', 'p__br_tmp50', 'established', 'p__br_tmp70'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp80 = p_src==20&&1==1;
 * recursive_merge: node ::  p__br_tmp70 = !(!(p_src==20))&&1==1;
 node outputs:  ['p__br_tmp70']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp60', 'p__br_tmp80', 'p__br_tmp50', 'established', 'p__br_tmp70'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp70 = !(!(p_src==20))&&1==1;
 * recursive_merge: node ::  p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;
 node outputs:  ['p__br_tmp60']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp60', 'p__br_tmp80', 'p__br_tmp50', 'established', 'p__br_tmp70'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;
 * recursive_merge: node ::  p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;
 node outputs:  ['p__br_tmp50']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp60', 'p__br_tmp80', 'p__br_tmp50', 'established', 'p__br_tmp70'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'p__br_tmp10', 'p__br_tmp60', 'p_established00', 'p__br_tmp40', 'p__br_tmp30', 'p__br_tmp80', 'p__br_tmp20', 'p_drop', 'p__br_tmp50', 'established', 'p__br_tmp70'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp60', 'p_src', 'p__br_tmp80', 'p__br_tmp50', 'p__br_tmp70']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp80', 'p__br_tmp70']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p_src', 'p__br_tmp80', 'p__br_tmp50', 'p__br_tmp70']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp70 = !(!(p_src==20))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp80', 'p__br_tmp50']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp80 = p_src==20&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp60', 'p_src', 'p__br_tmp50', 'p__br_tmp70']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p__br_tmp00', 'p__br_tmp60', 'p_drop0', 'p__br_tmp80', 'p_array_index0', 'p__br_tmp50', 'p__br_tmp70'}
{'p__br_tmp00', 'p__br_tmp60', 'p_drop0', 'p__br_tmp80', 'p_array_index0', 'p__br_tmp50', 'p__br_tmp70'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = !(!(!(!(!(!(!(p_src==20)))))))&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp50 = !(!(!(!(!(!(p_src==20))))))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp60 = !(!(!(!(p_src==20))))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp70 = !(!(p_src==20))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp80 = p_src==20&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = !(!(!(!(!(p_src==20)))))&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = !(!(!(p_src==20)))&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp30 = !(p_src==20)&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp40 = p_dst==20&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)&&(p__br_tmp30)&&(p__br_tmp40)) ? (p_established00==0) : (p_drop);
Error: stateful update does not fit in the stateful ALU.
node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp50)&&(p__br_tmp60)&&(p__br_tmp70)&&(p__br_tmp80)) ? (1) : (p_established00); established = p_established01;
inputs:  ['established', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp60', 'p__br_tmp70', 'p__br_tmp80']
outputs:  ['p_established00', 'established']
preprocessor time:
running mutation 7
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_7. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));

lhs p__br_tmp00 rhs !(!(!(!(p_src==20&&1==1))&&1==1))
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));

lhs p__br_tmp10 rhs 1==1&&!(!(p_src==20&&1==1))
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = 1==1&&1==1&&p_src==20;

lhs p__br_tmp20 rhs 1==1&&1==1&&p_src==20
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = 1==1&&1==1&&p_src==20;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p_established00']
p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);

lhs p__br_tmp30 rhs !(!(!(p_src==20&&1==1))&&1==1)
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp40 = 1==1&&!(p_src==20&&1==1);

lhs p__br_tmp40 rhs 1==1&&!(p_src==20&&1==1)
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = 1==1&&!(p_src==20&&1==1);

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp50 = 1==1&&1==1&&p_dst==20;

lhs p__br_tmp50 rhs 1==1&&1==1&&p_dst==20
state_vars {'established'}
read/write flanks: processing line  p__br_tmp50 = 1==1&&1==1&&p_dst==20;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);

lhs p_drop0 rhs (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40', 'p__br_tmp50', 'p_established01', 'p_drop']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00);
RAW p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1)); p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00);
RAW p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1)); p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
RAW p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1)); p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00);
RAW p__br_tmp20 = 1==1&&1==1&&p_src==20; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00);
RAW p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
RAW p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
RAW p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1); p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
RAW p__br_tmp40 = 1==1&&!(p_src==20&&1==1); p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
RAW p__br_tmp50 = 1==1&&1==1&&p_dst==20; p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7f89191efbb0>, 'write': <dependencyGraph.Statement object at 0x7f89181cc3d0>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7f89191efbb0>, 'write': <dependencyGraph.Statement object at 0x7f89181cc3d0>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  11
SCC 0
v p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop) stmts len 1
p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1)) stmts len 1
p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
SCC 4
v p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1)) stmts len 1
p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));
SCC 5
v p__br_tmp20 = 1==1&&1==1&&p_src==20 stmts len 1
p__br_tmp20 = 1==1&&1==1&&p_src==20;
SCC 6
v p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1) stmts len 1
p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);
SCC 7
v p__br_tmp40 = 1==1&&!(p_src==20&&1==1) stmts len 1
p__br_tmp40 = 1==1&&!(p_src==20&&1==1);
SCC 8
v p__br_tmp50 = 1==1&&1==1&&p_dst==20 stmts len 1
p__br_tmp50 = 1==1&&1==1&&p_dst==20;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f89181cca00>, <dependencyGraph.Codelet object at 0x7f89181cc970>, <dependencyGraph.Codelet object at 0x7f89181cc9a0>, <dependencyGraph.Codelet object at 0x7f89181cca60>, <dependencyGraph.Codelet object at 0x7f89181ccb80>, <dependencyGraph.Codelet object at 0x7f89181ccc40>, <dependencyGraph.Codelet object at 0x7f89181ccca0>, <dependencyGraph.Codelet object at 0x7f89181ccd00>, <dependencyGraph.Codelet object at 0x7f89181ccd60>]
p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));
p__br_tmp20 = 1==1&&1==1&&p_src==20;
p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);
p__br_tmp40 = 1==1&&!(p_src==20&&1==1);
p__br_tmp50 = 1==1&&1==1&&p_dst==20;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f89181cc970>}
total number of nodes created:  9
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established01'}
p_established01  is write flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  9
total number of nodes created:  9
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_7_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_7_out
Stored read, write flank variables
{'p_established00', 'p_established01'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  9
number of nodes in comp_graph:  9
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp50 = 1==1&&1==1&&p_dst==20;', 'p__br_tmp40 = 1==1&&!(p_src==20&&1==1);', 'p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);', 'p__br_tmp20 = 1==1&&1==1&&p_src==20;', 'p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));', 'p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));']
 * recursive_merge: node ::  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
     |  p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01']
redundant outputs ['p_established00']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp20', 'p__br_tmp30', 'p_drop', 'p__br_tmp10']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp20', 'p__br_tmp30', 'p_drop', 'p__br_tmp10']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
     |  p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
     |  p__br_tmp40 = 1==1&&!(p_src==20&&1==1);
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
     |  p__br_tmp50 = 1==1&&1==1&&p_dst==20;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['established', 'p_established01']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established01']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
redundant outputs []
adj_inputs ['p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));
redundant outputs []
adj_inputs ['p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01']
redundant outputs []
state_var ['established']
     | merged inputs:  ['established', 'p__br_tmp00', 'p__br_tmp20', 'p_src']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp20', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp20 = 1==1&&1==1&&p_src==20;
redundant outputs []
adj_inputs ['p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01']
redundant outputs []
state_var ['established']
     | merged inputs:  ['established', 'p__br_tmp00', 'p__br_tmp10', 'p_src']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp10', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_src', 'p_dst']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp50 = 1==1&&1==1&&p_dst==20;
 node outputs:  ['p__br_tmp50']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp50 = 1==1&&1==1&&p_dst==20;
 * recursive_merge: node ::  p__br_tmp40 = 1==1&&!(p_src==20&&1==1);
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = 1==1&&!(p_src==20&&1==1);
 * recursive_merge: node ::  p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp30', 'p_drop', 'p_established01'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);
 * recursive_merge: node ::  p__br_tmp20 = 1==1&&1==1&&p_src==20;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'established', 'p__br_tmp10', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = 1==1&&1==1&&p_src==20;
 * recursive_merge: node ::  p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp00', 'established', 'p__br_tmp10', 'p__br_tmp20'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));
 * recursive_merge: node ::  p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'established', 'p__br_tmp40', 'p__br_tmp00', 'p__br_tmp50', 'p__br_tmp20', 'p__br_tmp30', 'p_drop', 'p__br_tmp10', 'p_established01'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
 --- cannot fold. too many stateless inputs:  ['p__br_tmp20', 'p__br_tmp10', 'p_src']
trying to fold node:  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp20', 'p_src']
trying to fold node:  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp20 = 1==1&&1==1&&p_src==20;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp10', 'p_src']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p__br_tmp00', 'p__br_tmp20', 'p__br_tmp10', 'p_drop0', 'p_array_index0'}
{'p__br_tmp00', 'p__br_tmp20', 'p__br_tmp10', 'p_drop0', 'p_array_index0'}
u:  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
u:  p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
v:  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = !(!(!(!(p_src==20&&1==1))&&1==1));
v:  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
u:  p__br_tmp10 = 1==1&&!(!(p_src==20&&1==1));
v:  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp20 = 1==1&&1==1&&p_src==20;
v:  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp30 = !(!(!(p_src==20&&1==1))&&1==1);
v:  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
u:  p__br_tmp40 = 1==1&&!(p_src==20&&1==1);
v:  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
u:  p__br_tmp50 = 1==1&&1==1&&p_dst==20;
v:  p_drop0 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)&&(p__br_tmp50)) ? (p_established01==0) : (p_drop);
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20']
 ~~~| state var:  ['established']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_established00 = established; p_established01 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 problematic inputs:  ['established', 'p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20']
 problematic state vars:  ['established']
preprocessor time:
running mutation 8
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_8. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));

lhs p__br_tmp00 rhs 1==1&&!(1==1&&!(!(p_src==20)))
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;

lhs p__br_tmp10 rhs 1==1&&!(p_src==20)&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = 1==1&&p_dst==20&&1==1;

lhs p__br_tmp20 rhs 1==1&&p_dst==20&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = 1==1&&p_dst==20&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p_established00', 'p_drop']
p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;

lhs p__br_tmp30 rhs 1==1&&!(!(p_src==20))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp40 = 1==1&&p_src==20&&1==1;

lhs p__br_tmp40 rhs 1==1&&p_src==20&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = 1==1&&p_src==20&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20))); p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20))); p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp10 = 1==1&&!(p_src==20)&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = 1==1&&p_dst==20&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp40 = 1==1&&p_src==20&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7f38fcd7cbb0>, 'write': <dependencyGraph.Statement object at 0x7f38fbd5a7f0>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7f38fcd7cbb0>, 'write': <dependencyGraph.Statement object at 0x7f38fbd5a7f0>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  10
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20))) stmts len 1
p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
SCC 4
v p__br_tmp10 = 1==1&&!(p_src==20)&&1==1 stmts len 1
p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;
SCC 5
v p__br_tmp20 = 1==1&&p_dst==20&&1==1 stmts len 1
p__br_tmp20 = 1==1&&p_dst==20&&1==1;
SCC 6
v p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1 stmts len 1
p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;
SCC 7
v p__br_tmp40 = 1==1&&p_src==20&&1==1 stmts len 1
p__br_tmp40 = 1==1&&p_src==20&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f38fbd5a9d0>, <dependencyGraph.Codelet object at 0x7f38fbd5aac0>, <dependencyGraph.Codelet object at 0x7f38fbd5aa30>, <dependencyGraph.Codelet object at 0x7f38fbd5a040>, <dependencyGraph.Codelet object at 0x7f38fbd5aaf0>, <dependencyGraph.Codelet object at 0x7f38fbd5abb0>, <dependencyGraph.Codelet object at 0x7f38fbd5ac10>, <dependencyGraph.Codelet object at 0x7f38fbd5ac70>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;
p__br_tmp20 = 1==1&&p_dst==20&&1==1;
p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;
p__br_tmp40 = 1==1&&p_src==20&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f38fbd5aac0>}
total number of nodes created:  8
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  8
total number of nodes created:  8
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_8_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_8_out
Stored read, write flank variables
{'p_established01', 'p_established00'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  8
number of nodes in comp_graph:  8
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp20 = 1==1&&p_dst==20&&1==1;', 'p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;', 'p__br_tmp40 = 1==1&&p_src==20&&1==1;', 'p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;', 'p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p__br_tmp20', 'p__br_tmp00', 'p_established00', 'p__br_tmp10', 'p_drop']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p__br_tmp20', 'p__br_tmp00', 'p_established00', 'p__br_tmp10', 'p_drop']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp20', 'p__br_tmp40', 'p__br_tmp00', 'p__br_tmp10', 'p__br_tmp30', 'p_drop']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp20', 'p__br_tmp40', 'p__br_tmp00', 'p__br_tmp10', 'p__br_tmp30', 'p_drop']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp20 = 1==1&&p_dst==20&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['established', 'p_established00']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp20', 'p__br_tmp00', 'p_established00', 'p__br_tmp10', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
redundant outputs []
adj_inputs ['p__br_tmp20', 'p__br_tmp00', 'p_established00', 'p__br_tmp10', 'p_drop']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp20', 'p__br_tmp00', 'p_established00', 'p__br_tmp10', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp40', 'p__br_tmp00', 'established', 'p_src']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp40', 'p__br_tmp00', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp40 = 1==1&&p_src==20&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp20', 'p__br_tmp00', 'p_established00', 'p__br_tmp10', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p__br_tmp00', 'established', 'p__br_tmp30', 'p_src']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp00', 'p__br_tmp30', 'p_src']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_dst', 'p_src']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp20 = 1==1&&p_dst==20&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp20', 'p__br_tmp00', 'p_established00', 'p__br_tmp10', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = 1==1&&p_dst==20&&1==1;
 * recursive_merge: node ::  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp20', 'p__br_tmp00', 'p_established00', 'p__br_tmp10', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;
 * recursive_merge: node ::  p__br_tmp40 = 1==1&&p_src==20&&1==1;
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'established', 'p__br_tmp00', 'p__br_tmp30'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = 1==1&&p_src==20&&1==1;
 * recursive_merge: node ::  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'established', 'p__br_tmp00', 'p__br_tmp30'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp20', 'p__br_tmp40', 'p__br_tmp00', 'p_established00', 'established', 'p__br_tmp10', 'p__br_tmp30', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
 --- cannot fold. too many stateless inputs:  ['p__br_tmp40', 'p__br_tmp30', 'p_src']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp40', 'p__br_tmp00', 'p_src']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp40 = 1==1&&p_src==20&&1==1;
 --- cannot fold. too many stateless inputs:  ['p__br_tmp00', 'p__br_tmp30', 'p_src']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p_array_index0', 'p__br_tmp40', 'p__br_tmp00', 'p_drop0', 'p__br_tmp30'}
{'p_array_index0', 'p__br_tmp40', 'p__br_tmp00', 'p_drop0', 'p__br_tmp30'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = 1==1&&!(1==1&&!(!(p_src==20)));
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp30 = 1==1&&!(!(p_src==20))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp40 = 1==1&&p_src==20&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = 1==1&&!(p_src==20)&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = 1==1&&p_dst==20&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 ~~~| state var:  ['established']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 problematic inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 problematic state vars:  ['established']
preprocessor time:
running mutation 9
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_9. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;

lhs p__br_tmp00 rhs 1==1&&!(p_src==20&&1==1)&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;

lhs p__br_tmp10 rhs 1==1&&1==1&&p_dst==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p_established00', 'p_drop']
p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;

lhs p__br_tmp20 rhs 1==1&&1==1&&p_src==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp20', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00);
RAW p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00);
RAW p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7f116b00bbb0>, 'write': <dependencyGraph.Statement object at 0x7f1169fe93d0>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7f116b00bbb0>, 'write': <dependencyGraph.Statement object at 0x7f1169fe93d0>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  8
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1 stmts len 1
p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
SCC 4
v p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1 stmts len 1
p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;
SCC 5
v p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1 stmts len 1
p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f1169fe98b0>, <dependencyGraph.Codelet object at 0x7f1169fe9a30>, <dependencyGraph.Codelet object at 0x7f1169fe9130>, <dependencyGraph.Codelet object at 0x7f1169fe90d0>, <dependencyGraph.Codelet object at 0x7f1169fe9310>, <dependencyGraph.Codelet object at 0x7f1169fe9a90>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;
p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f1169fe9a30>}
total number of nodes created:  6
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  6
total number of nodes created:  6
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out
Stored read, write flank variables
{'p_established01', 'p_established00'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  6
number of nodes in comp_graph:  6
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;', 'p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;', 'p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p__br_tmp10', 'p__br_tmp00', 'p_established00', 'p_drop']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p_established00', 'p_drop']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp20', 'p_drop', 'p__br_tmp10', 'p__br_tmp00']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp20', 'p_drop', 'p__br_tmp10', 'p__br_tmp00']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['p_established00', 'established']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp20']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p_drop', 'p_established00', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p_established00', 'p_drop']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p_established00', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p_src', 'p__br_tmp00', 'established']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p_src', 'p__br_tmp00']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
 | b:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 | state_pkt_fields of component b:  ['p_established01', 'p_established00']
merge component: component is ----  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 ********************** adding statements from component  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;  with *************************
[<dependencyGraph.Statement object at 0x7f1169fe95b0>]
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p_established00', 'p_drop']
redundant outputs ['p_established01', 'p__br_tmp20']
state_var ['established']
resultant component: 
p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1; p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
new component inputs:  ['established', 'p__br_tmp00', 'p_src']
new component outputs:  ['p_established00', 'established']
new component state_pkt_fields:  ['p_established01', 'p_established00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p_src']
 ~~~| state var:  ['established']
salu_inputs {'metadata_lo': 'p__br_tmp00', 'metadata_hi': 'p_src', 'register_lo': 'established', 'register_hi': 0}
number of outputs for  pred_raw :  2
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  6
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_src', 'p_dst']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p_drop', 'p_established00', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp20', 'p__br_tmp00', 'established'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp20', 'p_drop', 'p_established00', 'p__br_tmp10', 'established', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
try_merge: trying to merge components: 
 | a:  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
 | b:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 | state_pkt_fields of component b:  ['p_established01', 'p_established00']
merge component: component is ----  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 ********************** adding statements from component  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;  with *************************
[<dependencyGraph.Statement object at 0x7f1169fe9730>]
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p_established00', 'p_drop']
redundant outputs ['p_established01']
state_var ['established']
resultant component: 
p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1; p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
new component inputs:  ['established', 'p__br_tmp20', 'p_src']
new component outputs:  ['established', 'p_established00', 'p__br_tmp00']
new component state_pkt_fields:  ['p_established01', 'p_established00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp20', 'p_src']
 ~~~| state var:  ['established']
salu_inputs {'metadata_lo': 'p__br_tmp20', 'metadata_hi': 'p_src', 'register_lo': 'established', 'register_hi': 0}
number of outputs for  pred_raw :  2
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_1_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_1_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_1_stateful.sk
return code 1
failed
---------- Merge failure. ---------
 --- cannot fold.
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
try_merge: trying to merge components: 
 | a:  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
 | b:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 | state_pkt_fields of component b:  ['p_established01', 'p_established00']
merge component: component is ----  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
 ********************** adding statements from component  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;  with *************************
[<dependencyGraph.Statement object at 0x7f1169fe95b0>]
adj_inputs ['p__br_tmp10', 'p__br_tmp00', 'p_established00', 'p_drop']
redundant outputs ['p_established01', 'p__br_tmp20']
state_var ['established']
resultant component: 
p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1; p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
new component inputs:  ['established', 'p__br_tmp00', 'p_src']
new component outputs:  ['p_established00', 'established']
new component state_pkt_fields:  ['p_established01', 'p_established00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p_src']
 ~~~| state var:  ['established']
salu_inputs {'metadata_lo': 'p__br_tmp00', 'metadata_hi': 'p_src', 'register_lo': 'established', 'register_hi': 0}
number of outputs for  pred_raw :  2
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_2_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_2_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/try_merge_query_2_stateful.sk
return code 1
failed
---------- Merge failure. ---------
 --- cannot fold.
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p__br_tmp20', 'p_drop0', 'p_array_index0', 'p__br_tmp00'}
{'p__br_tmp20', 'p_drop0', 'p_array_index0', 'p__br_tmp00'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = 1==1&&!(p_src==20&&1==1)&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = 1==1&&1==1&&p_src==20&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp20)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = 1==1&&1==1&&p_dst==20&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)) ? (p_established00==0) : (p_drop);
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p__br_tmp20']
 ~~~| state var:  ['established']
salu_inputs {'metadata_lo': 'p__br_tmp00', 'metadata_hi': 'p__br_tmp20', 'register_lo': 'established', 'register_hi': 0}
number of outputs for  pred_raw :  2
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/comp_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/comp_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_9_out/comp_0_stateful.sk
return code 1
failed
 --------- processing stateful output ---------
preprocessor time:
running mutation 10
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw, program name: stateful_fw_equivalent_10. Grammar: pred_raw. Continue?
------------------------------
Preprocessing done. Continuing
Using stateful ALU pred_raw
Using stateless ALU grammars/stateless_domino/stateless.sk
p_established00 = established;

lhs p_established00 rhs established
state_vars {'established'}
read/write flanks: processing line  p_established00 = established;

 is_read_flank: processing rhs_vars =  ['established']
read flank
p_array_index0 = p_src+p_dst;

lhs p_array_index0 rhs p_src+p_dst
state_vars {'established'}
read/write flanks: processing line  p_array_index0 = p_src+p_dst;

 is_read_flank: processing rhs_vars =  ['p_src', 'p_dst']
p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;

lhs p__br_tmp00 rhs !(!(!(p_src==20)&&1==1))&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp10 = !(p_src==20)&&1==1&&1==1;

lhs p__br_tmp10 rhs !(p_src==20)&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp10 = !(p_src==20)&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp20 = p_dst==20&&1==1&&1==1;

lhs p__br_tmp20 rhs p_dst==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp20 = p_dst==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_dst']
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

lhs p_drop0 rhs (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop)
state_vars {'established'}
read/write flanks: processing line  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp10', 'p__br_tmp20', 'p_established00', 'p_drop']
p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;

lhs p__br_tmp30 rhs !(!(p_src==20)&&1==1)&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p__br_tmp40 = p_src==20&&1==1&&1==1;

lhs p__br_tmp40 rhs p_src==20&&1==1&&1==1
state_vars {'established'}
read/write flanks: processing line  p__br_tmp40 = p_src==20&&1==1&&1==1;

 is_read_flank: processing rhs_vars =  ['p_src']
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

lhs p_established01 rhs (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00)
state_vars {'established'}
read/write flanks: processing line  p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40', 'p_established00']
established = p_established01;

lhs established rhs p_established01
state_vars {'established'}
read/write flanks: processing line  established = p_established01;

 is_read_flank: processing rhs_vars =  ['p_established01']
write flank
finding dependencies
RAW p_established00 = established; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp10 = !(p_src==20)&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp20 = p_dst==20&&1==1&&1==1; p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
RAW p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p__br_tmp40 = p_src==20&&1==1&&1==1; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
RAW p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
read_write_flanks {'established': {'read': <dependencyGraph.Statement object at 0x7f7f377e3bb0>, 'write': <dependencyGraph.Statement object at 0x7f7f367c17f0>}}
var:  established
{'read': <dependencyGraph.Statement object at 0x7f7f377e3bb0>, 'write': <dependencyGraph.Statement object at 0x7f7f367c17f0>}
state_var  established
read_flank p_established00 = established
write_flank established = p_established01
total number of nodes created:  10
SCC 0
v p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop) stmts len 1
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
SCC 1
v p_established00 = established stmts len 1
p_established00 = established;
v p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) stmts len 1
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
v established = p_established01 stmts len 1
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
SCC 2
v p_array_index0 = p_src+p_dst stmts len 1
p_array_index0 = p_src+p_dst;
SCC 3
v p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1 stmts len 1
p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
SCC 4
v p__br_tmp10 = !(p_src==20)&&1==1&&1==1 stmts len 1
p__br_tmp10 = !(p_src==20)&&1==1&&1==1;
SCC 5
v p__br_tmp20 = p_dst==20&&1==1&&1==1 stmts len 1
p__br_tmp20 = p_dst==20&&1==1&&1==1;
SCC 6
v p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1 stmts len 1
p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;
SCC 7
v p__br_tmp40 = p_src==20&&1==1&&1==1 stmts len 1
p__br_tmp40 = p_src==20&&1==1&&1==1;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f7f367c19d0>, <dependencyGraph.Codelet object at 0x7f7f367c1ac0>, <dependencyGraph.Codelet object at 0x7f7f367c1a30>, <dependencyGraph.Codelet object at 0x7f7f367c1070>, <dependencyGraph.Codelet object at 0x7f7f367c1af0>, <dependencyGraph.Codelet object at 0x7f7f367c1bb0>, <dependencyGraph.Codelet object at 0x7f7f367c1c10>, <dependencyGraph.Codelet object at 0x7f7f367c1c70>]
p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
p_established00 = established;
p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00);
established = p_established01;
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
stateful
p_array_index0 = p_src+p_dst;
p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
p__br_tmp10 = !(p_src==20)&&1==1&&1==1;
p__br_tmp20 = p_dst==20&&1==1&&1==1;
p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;
p__br_tmp40 = p_src==20&&1==1&&1==1;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f7f367c1ac0>}
total number of nodes created:  8
state vars {'established'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  {'p_established00'}
p_established00  is read flank
everything fits within a stateful ALU. No need to do anything.
number of SCC nodes post splitting:  8
total number of nodes created:  8
TODO: call synthesizer
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_10_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/stateful_fw/stateful_fw_equivalent_10_out
Stored read, write flank variables
{'p_established00', 'p_established01'}
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
-------------------------------------- stateful codelet vars :  ['established'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['established']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
codelet  p_established00 = established p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00) established = p_established01  is stateful
number of nodes on SCC_GRAPH:  8
number of nodes in comp_graph:  8
 * recursive_merge strategy: nodes ordered  ['p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);', 'p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;', 'p_array_index0 = p_src+p_dst;', 'p__br_tmp20 = p_dst==20&&1==1&&1==1;', 'p__br_tmp10 = !(p_src==20)&&1==1&&1==1;', 'p__br_tmp40 = p_src==20&&1==1&&1==1;', 'p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;', 'p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;']
 * recursive_merge: node ::  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 node outputs:  ['p_drop0']
 node inputs:  ['p__br_tmp10', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p_drop']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
adj_inputs ['p__br_tmp10', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p_drop']
redundant outputs ['p_established01']
state_var ['established']
redundant outputs []
     | merged inputs:  ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p__br_tmp40', 'p_drop', 'p__br_tmp30']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p__br_tmp10', 'p__br_tmp00', 'p__br_tmp20', 'p__br_tmp40', 'p_drop', 'p__br_tmp30']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp10 = !(p_src==20)&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
     |  p__br_tmp20 = p_dst==20&&1==1&&1==1;
redundant outputs []
redundant outputs []
    ~ merge_candidate: both components are stateless.
     | not a merge candidate.
 * recursive_merge: finished processing  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
 * recursive_merge: node ::  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 node outputs:  ['p_established00', 'established']
 node inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_established00']
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p_drop']
redundant outputs []
state_var ['established']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p_src', 'established', 'p__br_tmp00', 'p__br_tmp40']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p_src', 'p__br_tmp00', 'p__br_tmp40']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
     |  p__br_tmp40 = p_src==20&&1==1&&1==1;
redundant outputs []
adj_inputs ['p__br_tmp10', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p_drop']
redundant outputs []
state_var ['established']
     | merged inputs:  ['p_src', 'established', 'p__br_tmp00', 'p__br_tmp30']
		| merged state vars:  {'established'}
		| merged stateless vars:  ['p_src', 'p__br_tmp00', 'p__br_tmp30']
 	| cannot merge: too many inputs.
     | not a merge candidate.
 * recursive_merge: finished processing  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 * recursive_merge: node ::  p_array_index0 = p_src+p_dst;
 node outputs:  ['p_array_index0']
 node inputs:  ['p_src', 'p_dst']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_array_index0 = p_src+p_dst;
 * recursive_merge: node ::  p__br_tmp20 = p_dst==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp20']
 node inputs:  ['p_dst']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp20 = p_dst==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp10 = !(p_src==20)&&1==1&&1==1;
 node outputs:  ['p__br_tmp10']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p_drop'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp10 = !(p_src==20)&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp40 = p_src==20&&1==1&&1==1;
 node outputs:  ['p__br_tmp40']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'p__br_tmp30', 'established', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp40 = p_src==20&&1==1&&1==1;
 * recursive_merge: node ::  p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;
 node outputs:  ['p__br_tmp30']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp40', 'p__br_tmp30', 'established', 'p__br_tmp00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;
 * recursive_merge: node ::  p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
 node outputs:  ['p__br_tmp00']
 node inputs:  ['p_src']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp10', 'established', 'p_established00', 'p__br_tmp00', 'p__br_tmp20', 'p__br_tmp40', 'p_drop', 'p__br_tmp30'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
 ----------------- iteratively folding node. folding_idx =  0
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
 --- cannot fold. too many stateless inputs:  ['p_src', 'p__br_tmp40', 'p__br_tmp30']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;
 --- cannot fold. too many stateless inputs:  ['p_src', 'p__br_tmp00', 'p__br_tmp40']
trying to fold node:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
trying to fold predecessor:  p__br_tmp40 = p_src==20&&1==1&&1==1;
 --- cannot fold. too many stateless inputs:  ['p_src', 'p__br_tmp00', 'p__br_tmp30']
 is_read_flank: processing rhs_vars =  ['established']
 is_read_flank: processing rhs_vars =  ['p_established01']
Principal Outputs:  {'p_array_index0', 'p__br_tmp00', 'p_drop0', 'p__br_tmp40', 'p__br_tmp30'}
{'p_array_index0', 'p__br_tmp00', 'p_drop0', 'p__br_tmp40', 'p__br_tmp30'}
u:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp00 = !(!(!(p_src==20)&&1==1))&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp30 = !(!(p_src==20)&&1==1)&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp40 = p_src==20&&1==1&&1==1;
v:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
u:  p__br_tmp10 = !(p_src==20)&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
u:  p__br_tmp20 = p_dst==20&&1==1&&1==1;
v:  p_drop0 = (1&&(p__br_tmp00)&&(p__br_tmp10)&&(p__br_tmp20)) ? (p_established00==0) : (p_drop);
~~~~~~~~~~set_alu_inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 ~~~| state var:  ['established']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_established00 = established; p_established01 = (1&&!(p__br_tmp00)&&(p__br_tmp30)&&(p__br_tmp40)) ? (1) : (p_established00); established = p_established01;
 problematic inputs:  ['established', 'p__br_tmp00', 'p__br_tmp30', 'p__br_tmp40']
 problematic state vars:  ['established']
preprocessor time:
