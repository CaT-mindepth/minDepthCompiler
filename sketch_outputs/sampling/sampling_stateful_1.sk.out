SKETCH version 1.7.6
Benchmark = sampling_stateful_1.sk
/* BEGIN PACKAGE ANONYMOUS*/
/*samplin..eful_1.sk:81*/

void bool_op (int opcode, bit o1, bit o2, ref bit _out)/*samplin..eful_1.sk:81*/
{
  if(opcode == 0)/*samplin..eful_1.sk:82*/
  {
    _out = 0;
    return;
  }
  if(opcode == 1)/*samplin..eful_1.sk:85*/
  {
    _out = !(o1 | o2);
    return;
  }
  if(opcode == 2)/*samplin..eful_1.sk:88*/
  {
    _out = (!(o1)) & o2;
    return;
  }
  if(opcode == 3)/*samplin..eful_1.sk:91*/
  {
    _out = !(o1);
    return;
  }
  if(opcode == 4)/*samplin..eful_1.sk:94*/
  {
    _out = o1 & (!(o2));
    return;
  }
  if(opcode == 5)/*samplin..eful_1.sk:97*/
  {
    _out = !(o2);
    return;
  }
  if(opcode == 6)/*samplin..eful_1.sk:100*/
  {
    _out = o1 & o2;
    return;
  }
  if(opcode == 7)/*samplin..eful_1.sk:104*/
  {
    _out = !(o1 & o2);
    return;
  }
  if(opcode == 8)/*samplin..eful_1.sk:107*/
  {
    _out = o1 & o2;
    return;
  }
  if(opcode == 9)/*samplin..eful_1.sk:110*/
  {
    _out = !(o1 & o2);
    return;
  }
  if(opcode == 10)/*samplin..eful_1.sk:114*/
  {
    _out = o2;
    return;
  }
  if(opcode == 11)/*samplin..eful_1.sk:117*/
  {
    _out = (!(o1)) | o2;
    return;
  }
  if(opcode == 12)/*samplin..eful_1.sk:120*/
  {
    _out = o1;
    return;
  }
  if(opcode == 13)/*samplin..eful_1.sk:123*/
  {
    _out = o1 | (!(o2));
    return;
  }
  if(opcode == 14)/*samplin..eful_1.sk:126*/
  {
    _out = o1 | o2;
    return;
  }
  else
  {
    _out = 1;
    return;
  }
}
/*samplin..eful_1.sk:136*/

void compute_alu (int op, int o1, int o2, ref int _out)/*samplin..eful_1.sk:136*/
{
  if(op == 0)/*samplin..eful_1.sk:137*/
  {
    _out = o1 + o2;
    return;
  }
  if(op == 1)/*samplin..eful_1.sk:140*/
  {
    _out = o1 - o2;
    return;
  }
  if(op == 2)/*samplin..eful_1.sk:143*/
  {
    _out = o2 - o1;
    return;
  }
  if(op == 3)/*samplin..eful_1.sk:146*/
  {
    _out = o2;
    return;
  }
  if(op == 4)/*samplin..eful_1.sk:149*/
  {
    _out = o1;
    return;
  }
  if(op == 5)/*samplin..eful_1.sk:152*/
  {
    _out = 0;
    return;
  }
  else
  {
    _out = 1;
    return;
  }
}
/*samplin..eful_1.sk:160*/

void salu (int metadata_lo, int metadata_hi, int register_lo_0, int register_hi_1, ref int[2] _out)/*samplin..eful_1.sk:160*/
{
  _out = ((int[2])0);
  int register_hi = register_hi_1;
  int register_lo = register_lo_0;
  int update_hi_1_value_s13 = 0;
  compute_alu(0, 2, 0, update_hi_1_value_s13)//{};
  int update_hi_2_value_s23 = 0;
  compute_alu(7, metadata_hi, register_hi_1, update_hi_2_value_s23)//{};
  int update_lo_1_value_s33 = 0;
  compute_alu(3, 14, register_hi_1, update_lo_1_value_s33)//{};
  int update_lo_2_value_s43 = 0;
  compute_alu(0, 1, register_lo_0, update_lo_2_value_s43)//{};
  bit condition_hi_s55 = ((0 - register_lo_0) + 29) == 0;
  bit condition_lo_s67 = ((0 - metadata_lo) - register_lo_0) > 0;
  bit update_hi_1_predicate_s69 = 0;
  bool_op(6, condition_hi_s55, condition_lo_s67, update_hi_1_predicate_s69);
  bit update_hi_2_predicate_s71 = 0;
  bool_op(12, condition_hi_s55, condition_lo_s67, update_hi_2_predicate_s71);
  bit update_lo_1_predicate_s73 = 0;
  bool_op(12, condition_hi_s55, condition_lo_s67, update_lo_1_predicate_s73);
  bit update_lo_2_predicate_s75 = 0;
  bool_op(11, condition_hi_s55, condition_lo_s67, update_lo_2_predicate_s75);
  assert (!(update_hi_1_predicate_s69 && update_hi_2_predicate_s71)); //ASSERTION CAN NOT BE SATISFIED: samplin..eful_1.sk:196 Assert at samplin..eful_1.sk:196 (1)
  if(update_hi_1_predicate_s69 && (!(update_hi_2_predicate_s71)))/*samplin..eful_1.sk:197*/
  {
    register_hi = update_hi_1_value_s13;
  }
  else
  {
    if((!(update_hi_1_predicate_s69)) && update_hi_2_predicate_s71)/*samplin..eful_1.sk:199*/
    {
      register_hi = update_hi_2_value_s23;
    }
    else
    {
      register_hi = register_hi_1;
    }
  }
  assert (!(update_lo_1_predicate_s73 && update_lo_2_predicate_s75)); //ASSERTION CAN NOT BE SATISFIED: samplin..eful_1.sk:207 Assert at samplin..eful_1.sk:207 (1)
  if(update_lo_1_predicate_s73 && (!(update_lo_2_predicate_s75)))/*samplin..eful_1.sk:208*/
  {
    register_lo = update_lo_1_value_s33;
  }
  else
  {
    if((!(update_lo_1_predicate_s73)) && update_lo_2_predicate_s75)/*samplin..eful_1.sk:210*/
    {
      register_lo = update_lo_2_value_s43;
    }
    else
    {
      register_lo = register_lo_0;
    }
  }
  _out[0] = register_lo;
  _out[1] = register_hi;
  return;
}
/*samplin..eful_1.sk:245*/

void sampling_1 (int p_sample_0, int count_1, ref int[2] _out)/*samplin..eful_1.sk:245*/
{
  _out = ((int[2])0);
  int count = count_1;
  int p_sample = p_sample_0;
  if(count_1 == 29)/*samplin..eful_1.sk:247*/
  {
    p_sample = 1;
    count = 0;
  }
  else
  {
    p_sample = 0;
    count = count_1 + 1;
  }
  _out[0] = count;
  _out[1] = p_sample;
  return;
}
/*samplin..eful_1.sk:259*/

void sketch (int p_sample, int count)/*samplin..eful_1.sk:259*/
{
  int[2] impl_s1 = {0,0};
  salu(p_sample, 0, count, 0, impl_s1);
  int[2] spec_s3 = {0,0};
  sampling_1(p_sample, count, spec_s3);
  assert ((impl_s1[0]) == (spec_s3[0])); //Assert at samplin..eful_1.sk:262 (1)
  assert ((impl_s1[1]) == (spec_s3[1])); //Assert at samplin..eful_1.sk:263 (1)
}
/*samplin..eful_1.sk:259*/

void sketch__Wrapper (int p_sample, int count)  implements sketch__WrapperNospec/*samplin..eful_1.sk:259*/
{
  sketch(p_sample, count);
}
/*samplin..eful_1.sk:259*/

void sketch__WrapperNospec (int p_sample, int count)/*samplin..eful_1.sk:259*/
{ }
/* END PACKAGE ANONYMOUS*/
[SKETCH] DONE
Total time = 282
