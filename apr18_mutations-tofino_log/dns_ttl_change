running mutation 1
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_1. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp5 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp6 = p_seen00==0;

lhs p__br_tmp6 rhs p_seen00==0
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p__br_tmp6 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp6 ? (1) : (p_seen00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_seen00']
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp6 ? (0) : (p_ttl_change01)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp6 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp6 = p_seen00==0; p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp6 = p_seen00==0; p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'ttl_change': {'read': <dependencyGraph.Statement object at 0x7f45d4f81580>, 'write': <dependencyGraph.Statement object at 0x7f45d4f81400>}, 'seen': {'read': <dependencyGraph.Statement object at 0x7f45d4f81160>, 'write': <dependencyGraph.Statement object at 0x7f45d4f811f0>}, 'last_ttl': {'read': <dependencyGraph.Statement object at 0x7f45d4f815b0>, 'write': <dependencyGraph.Statement object at 0x7f45d4f814f0>}}
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7f45d4f81580>, 'write': <dependencyGraph.Statement object at 0x7f45d4f81400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  seen
{'read': <dependencyGraph.Statement object at 0x7f45d4f81160>, 'write': <dependencyGraph.Statement object at 0x7f45d4f811f0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7f45d4f815b0>, 'write': <dependencyGraph.Statement object at 0x7f45d4f814f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp6 = p_seen00==0 stmts len 1
p__br_tmp6 = p_seen00==0;
v p_seen01 = p__br_tmp6 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f45d4f81c70>, <dependencyGraph.Codelet object at 0x7f45d4f81df0>, <dependencyGraph.Codelet object at 0x7f45d4f81bb0>, <dependencyGraph.Codelet object at 0x7f45d4f81d90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp6 = p_seen00==0;
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f45d4f81df0>, <dependencyGraph.Codelet object at 0x7f45d4f81bb0>, <dependencyGraph.Codelet object at 0x7f45d4f81c70>}
total number of nodes created:  4
state vars {'ttl_change', 'seen', 'last_ttl'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp5'}
elements in v_outputs:  {'p__br_tmp5'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp5'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p__br_tmp5  not in state vars
 statement:  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp5'}
   - createing a node for flank  p__br_tmp5
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p_seen00', 'p__br_tmp6'}
p_seen00  is read flank
elements in v_outputs:  {'p_seen00', 'p__br_tmp6'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp6'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp6 = p_seen00==0
2   p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
3   seen = p_seen01
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
p__br_tmp6  not in state vars
 statement:  p__br_tmp6 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp6', 'p_seen00']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p_seen00', 'p__br_tmp6'}
   - createing a node for flank  p__br_tmp6
   - createing a node for flank  p_seen00
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_1_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_1_out
Stored read, write flank variables
{'p_seen01', 'p_ttl_change00', 'p_seen00', 'p_last_ttl02', 'p_ttl_change02', 'p_last_ttl00'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['p_ttl_change01', 'p_ttl_change00', 'ttl_change', 'p_ttl_change02']
 node inputs:  ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_last_ttl02', 'p_last_ttl00', 'p_last_ttl01']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change01', 'p_ttl_change00', 'p_ttl_change02']
state_var ['ttl_change']
     | merged inputs:  ['p_seen00', 'ttl_change', 'p__br_tmp6', 'p_ttl']
		| merged state vars:  {'ttl_change', 'last_ttl'}
		| merged stateless vars:  ['p_seen00', 'p__br_tmp6', 'p_ttl']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p__br_tmp6', 'p_ttl', 'ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['p__br_tmp5', 'last_ttl']
 node inputs:  ['last_ttl', 'p_seen00', 'p__br_tmp6', 'p_ttl']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp5', 'p__br_tmp6', 'ttl_change'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p__br_tmp6', 'p_ttl']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['last_ttl', 'p_ttl']
		| merged state vars:  {'seen', 'last_ttl'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen00', 'p_seen01']
 | state_pkt_fields of component b:  ['p_last_ttl00', 'p_last_ttl02']
merge component: component is ----  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f45d4f815b0>, <dependencyGraph.Statement object at 0x7f45d4f81100>, <dependencyGraph.Statement object at 0x7f45d4f81520>, <dependencyGraph.Statement object at 0x7f45d4f81370>, <dependencyGraph.Statement object at 0x7f45d4f814f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_last_ttl01', 'p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl00']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['seen', 'p__br_tmp5', 'p__br_tmp6', 'last_ttl']
new component state_pkt_fields:  ['p_seen00', 'p_seen01', 'p_last_ttl00', 'p_last_ttl02']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_1_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_1_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_1_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p__br_tmp6', 'p_ttl', 'ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p_seen00', 'p__br_tmp6', 'seen']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'p__br_tmp5', 'ttl_change', 'p__br_tmp6', 'last_ttl', 'p_ttl'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p_seen00', 'p__br_tmp6', 'seen']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'p__br_tmp6', 'last_ttl', 'p_ttl'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p_seen00', 'p__br_tmp6', 'p_ttl']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p_seen00', 'p__br_tmp6', 'p_ttl']
 problematic state vars:  ['last_ttl']
preprocessor time:
running mutation 2
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_2. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp5 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp6 = p_seen00==0;

lhs p__br_tmp6 rhs p_seen00==0
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p__br_tmp6 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp6 ? (1) : (p_seen00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_seen00']
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp6 ? (0) : (p_ttl_change01)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp6 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp6 = p_seen00==0; p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp6 = p_seen00==0; p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'last_ttl': {'read': <dependencyGraph.Statement object at 0x7f23517485b0>, 'write': <dependencyGraph.Statement object at 0x7f23517484f0>}, 'ttl_change': {'read': <dependencyGraph.Statement object at 0x7f2351748580>, 'write': <dependencyGraph.Statement object at 0x7f2351748400>}, 'seen': {'read': <dependencyGraph.Statement object at 0x7f2351748160>, 'write': <dependencyGraph.Statement object at 0x7f23517481f0>}}
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7f23517485b0>, 'write': <dependencyGraph.Statement object at 0x7f23517484f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7f2351748580>, 'write': <dependencyGraph.Statement object at 0x7f2351748400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  seen
{'read': <dependencyGraph.Statement object at 0x7f2351748160>, 'write': <dependencyGraph.Statement object at 0x7f23517481f0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp6 = p_seen00==0 stmts len 1
p__br_tmp6 = p_seen00==0;
v p_seen01 = p__br_tmp6 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f2351748c70>, <dependencyGraph.Codelet object at 0x7f2351748df0>, <dependencyGraph.Codelet object at 0x7f2351748bb0>, <dependencyGraph.Codelet object at 0x7f2351748d90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp6 = p_seen00==0;
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f2351748df0>, <dependencyGraph.Codelet object at 0x7f2351748bb0>, <dependencyGraph.Codelet object at 0x7f2351748c70>}
total number of nodes created:  4
state vars {'last_ttl', 'ttl_change', 'seen'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp5'}
elements in v_outputs:  {'p__br_tmp5'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp5'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
p__br_tmp5  not in state vars
 statement:  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp5'}
   - createing a node for flank  p__br_tmp5
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p_seen00', 'p__br_tmp6'}
p_seen00  is read flank
elements in v_outputs:  {'p_seen00', 'p__br_tmp6'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp6'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp6 = p_seen00==0
2   p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
3   seen = p_seen01
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
p__br_tmp6  not in state vars
 statement:  p__br_tmp6 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp6', 'p_seen00']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p_seen00', 'p__br_tmp6'}
   - createing a node for flank  p__br_tmp6
   - createing a node for flank  p_seen00
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_2_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_2_out
Stored read, write flank variables
{'p_last_ttl02', 'p_seen00', 'p_last_ttl00', 'p_ttl_change00', 'p_seen01', 'p_ttl_change02'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['ttl_change', 'p_ttl_change01', 'p_ttl_change02', 'p_ttl_change00']
 node inputs:  ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_last_ttl02', 'p_last_ttl00', 'p_last_ttl01']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change01', 'p_ttl_change02', 'p_ttl_change00']
state_var ['ttl_change']
     | merged inputs:  ['p_seen00', 'p__br_tmp6', 'p_ttl', 'ttl_change']
		| merged state vars:  {'last_ttl', 'ttl_change'}
		| merged stateless vars:  ['p_seen00', 'p__br_tmp6', 'p_ttl']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00', 'ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['last_ttl', 'p__br_tmp5']
 node inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 exclude_read_write_flanks: successor inputs:  {'ttl_change', 'p__br_tmp6', 'p__br_tmp5'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['last_ttl', 'p_ttl']
		| merged state vars:  {'last_ttl', 'seen'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen00', 'p_seen01']
 | state_pkt_fields of component b:  ['p_last_ttl02', 'p_last_ttl00']
merge component: component is ----  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f23517485b0>, <dependencyGraph.Statement object at 0x7f2351748100>, <dependencyGraph.Statement object at 0x7f2351748520>, <dependencyGraph.Statement object at 0x7f2351748370>, <dependencyGraph.Statement object at 0x7f23517484f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_seen00', 'p_last_ttl02', 'p_last_ttl00', 'p_last_ttl01', 'p_seen01']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['p__br_tmp5', 'last_ttl', 'p__br_tmp6', 'seen']
new component state_pkt_fields:  ['p_seen00', 'p_seen01', 'p_last_ttl02', 'p_last_ttl00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_2_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_2_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_2_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00', 'ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['seen', 'p_seen00', 'p__br_tmp6']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'last_ttl', 'p__br_tmp6', 'p_ttl', 'ttl_change', 'p__br_tmp5'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['seen', 'p_seen00', 'p__br_tmp6']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_ttl', 'last_ttl', 'p__br_tmp6', 'p_seen00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 problematic state vars:  ['last_ttl']
preprocessor time:
running mutation 3
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_3. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp7 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp7 ? (p_ttl) : (p_last_ttl00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp7', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp7', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp8 = p_seen00==0;

lhs p__br_tmp8 rhs p_seen00==0
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p__br_tmp8 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp8 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp8 ? (1) : (p_seen00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_seen01 = p__br_tmp8 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp8', 'p_seen00']
p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp8 ? (p_ttl) : (p_last_ttl01)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp8', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp8 ? (0) : (p_ttl_change01)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp8', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp8 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp8 ? (1) : (p_seen00);
RAW p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01);
RAW p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00);
RAW p__br_tmp8 = p_seen00==0; p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp8 = p_seen00==0; p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'last_ttl': {'read': <dependencyGraph.Statement object at 0x7f94c28c25b0>, 'write': <dependencyGraph.Statement object at 0x7f94c28c24f0>}, 'ttl_change': {'read': <dependencyGraph.Statement object at 0x7f94c28c2580>, 'write': <dependencyGraph.Statement object at 0x7f94c28c2400>}, 'seen': {'read': <dependencyGraph.Statement object at 0x7f94c28c2160>, 'write': <dependencyGraph.Statement object at 0x7f94c28c21f0>}}
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7f94c28c25b0>, 'write': <dependencyGraph.Statement object at 0x7f94c28c24f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7f94c28c2580>, 'write': <dependencyGraph.Statement object at 0x7f94c28c2400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  seen
{'read': <dependencyGraph.Statement object at 0x7f94c28c2160>, 'write': <dependencyGraph.Statement object at 0x7f94c28c21f0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp8 = p_seen00==0 stmts len 1
p__br_tmp8 = p_seen00==0;
v p_seen01 = p__br_tmp8 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp8 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f94c28c2c70>, <dependencyGraph.Codelet object at 0x7f94c28c2df0>, <dependencyGraph.Codelet object at 0x7f94c28c2bb0>, <dependencyGraph.Codelet object at 0x7f94c28c2d90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp8 = p_seen00==0;
p_seen01 = p__br_tmp8 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f94c28c2df0>, <dependencyGraph.Codelet object at 0x7f94c28c2bb0>, <dependencyGraph.Codelet object at 0x7f94c28c2c70>}
total number of nodes created:  4
state vars {'last_ttl', 'ttl_change', 'seen'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp7'}
elements in v_outputs:  {'p__br_tmp7'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp7'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp7', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
p__br_tmp7  not in state vars
 statement:  p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp8', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp7'}
   - createing a node for flank  p__br_tmp7
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p__br_tmp8', 'p_seen00'}
p_seen00  is read flank
elements in v_outputs:  {'p__br_tmp8', 'p_seen00'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp8'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp8 = p_seen00==0
2   p_seen01 = p__br_tmp8 ? (1) : (p_seen00)
3   seen = p_seen01
p__br_tmp8  not in state vars
 statement:  p__br_tmp8 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp8 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp8', 'p_seen00']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p__br_tmp8', 'p_seen00'}
   - createing a node for flank  p_seen00
   - createing a node for flank  p__br_tmp8
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_3_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_3_out
Stored read, write flank variables
{'p_ttl_change02', 'p_last_ttl00', 'p_seen01', 'p_seen00', 'p_last_ttl02', 'p_ttl_change00'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp8 = p_seen00==0 p_seen01 = p__br_tmp8 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp8 = p_seen00==0 p_seen01 = p__br_tmp8 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp8 = p_seen00==0 p_seen01 = p__br_tmp8 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp8 = p_seen00==0 p_seen01 = p__br_tmp8 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp8 = p_seen00==0 p_seen01 = p__br_tmp8 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['p_ttl_change01', 'ttl_change', 'p_ttl_change02', 'p_ttl_change00']
 node inputs:  ['ttl_change', 'p__br_tmp8', 'p__br_tmp7']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp8', 'p__br_tmp7']
redundant outputs ['p_last_ttl00', 'p_last_ttl01', 'p_last_ttl02']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change01', 'p_ttl_change02', 'p_ttl_change00']
state_var ['ttl_change']
     | merged inputs:  ['p_ttl', 'ttl_change', 'p__br_tmp8', 'p_seen00']
		| merged state vars:  {'last_ttl', 'ttl_change'}
		| merged stateless vars:  ['p_ttl', 'p__br_tmp8', 'p_seen00']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p__br_tmp8', 'p_ttl', 'ttl_change', 'p__br_tmp8', 'p__br_tmp7']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['last_ttl', 'p__br_tmp7']
 node inputs:  ['last_ttl', 'p_seen00', 'p__br_tmp8', 'p_ttl']
 exclude_read_write_flanks: successor inputs:  {'ttl_change', 'p__br_tmp8', 'p__br_tmp7'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p__br_tmp8', 'p_ttl', 'ttl_change', 'p__br_tmp8', 'p__br_tmp7']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp8', 'p__br_tmp7']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p__br_tmp8', 'p_ttl']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp8', 'p__br_tmp7']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['last_ttl', 'p_ttl']
		| merged state vars:  {'last_ttl', 'seen'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen00', 'p_seen01']
 | state_pkt_fields of component b:  ['p_last_ttl00', 'p_last_ttl02']
merge component: component is ----  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f94c28c25b0>, <dependencyGraph.Statement object at 0x7f94c28c2100>, <dependencyGraph.Statement object at 0x7f94c28c2520>, <dependencyGraph.Statement object at 0x7f94c28c2370>, <dependencyGraph.Statement object at 0x7f94c28c24f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp8', 'p__br_tmp7']
redundant outputs ['p_last_ttl00', 'p_last_ttl01', 'p_seen01', 'p_seen00', 'p_last_ttl02']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['last_ttl', 'p__br_tmp7', 'p__br_tmp8', 'seen']
new component state_pkt_fields:  ['p_seen00', 'p_seen01', 'p_last_ttl00', 'p_last_ttl02']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_3_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_3_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_3_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p__br_tmp8', 'p_seen00', 'seen']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'last_ttl', 'p_seen00', 'p__br_tmp8', 'p_ttl'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p__br_tmp8', 'p_seen00', 'seen']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'last_ttl', 'p_ttl', 'ttl_change', 'p__br_tmp7', 'p__br_tmp8', 'p_seen00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp7 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp8 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp8 = p_seen00==0; p_seen01 = p__br_tmp8 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p_seen00', 'p__br_tmp8', 'p_ttl']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp7 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp7 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp8 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p_seen00', 'p__br_tmp8', 'p_ttl']
 problematic state vars:  ['last_ttl']
preprocessor time:
running mutation 4
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_4. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp5 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp6 = p_seen00==0;

lhs p__br_tmp6 rhs p_seen00==0
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p__br_tmp6 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp6 ? (1) : (p_seen00)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_seen00']
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp6 ? (0) : (p_ttl_change01)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp6 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp6 = p_seen00==0; p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp6 = p_seen00==0; p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'ttl_change': {'read': <dependencyGraph.Statement object at 0x7fb32d9fe580>, 'write': <dependencyGraph.Statement object at 0x7fb32d9fe400>}, 'last_ttl': {'read': <dependencyGraph.Statement object at 0x7fb32d9fe5b0>, 'write': <dependencyGraph.Statement object at 0x7fb32d9fe4f0>}, 'seen': {'read': <dependencyGraph.Statement object at 0x7fb32d9fe160>, 'write': <dependencyGraph.Statement object at 0x7fb32d9fe1f0>}}
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7fb32d9fe580>, 'write': <dependencyGraph.Statement object at 0x7fb32d9fe400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7fb32d9fe5b0>, 'write': <dependencyGraph.Statement object at 0x7fb32d9fe4f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
var:  seen
{'read': <dependencyGraph.Statement object at 0x7fb32d9fe160>, 'write': <dependencyGraph.Statement object at 0x7fb32d9fe1f0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp6 = p_seen00==0 stmts len 1
p__br_tmp6 = p_seen00==0;
v p_seen01 = p__br_tmp6 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7fb32d9fec70>, <dependencyGraph.Codelet object at 0x7fb32d9fedf0>, <dependencyGraph.Codelet object at 0x7fb32d9febb0>, <dependencyGraph.Codelet object at 0x7fb32d9fed90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp6 = p_seen00==0;
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7fb32d9fedf0>, <dependencyGraph.Codelet object at 0x7fb32d9febb0>, <dependencyGraph.Codelet object at 0x7fb32d9fec70>}
total number of nodes created:  4
state vars {'ttl_change', 'last_ttl', 'seen'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp5'}
elements in v_outputs:  {'p__br_tmp5'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp5'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
p__br_tmp5  not in state vars
 statement:  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp5'}
   - createing a node for flank  p__br_tmp5
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p__br_tmp6', 'p_seen00'}
p_seen00  is read flank
elements in v_outputs:  {'p__br_tmp6', 'p_seen00'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp6'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp6 = p_seen00==0
2   p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
3   seen = p_seen01
p__br_tmp6  not in state vars
 statement:  p__br_tmp6 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp6', 'p_seen00']
 state vars:  ['seen']
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p__br_tmp6', 'p_seen00'}
   - createing a node for flank  p_seen00
   - createing a node for flank  p__br_tmp6
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_4_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_4_out
Stored read, write flank variables
{'p_last_ttl00', 'p_ttl_change02', 'p_ttl_change00', 'p_last_ttl02', 'p_seen01', 'p_seen00'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['ttl_change', 'p_ttl_change02', 'p_ttl_change01', 'p_ttl_change00']
 node inputs:  ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_last_ttl00', 'p_last_ttl01', 'p_last_ttl02']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change02', 'p_ttl_change01', 'p_ttl_change00']
state_var ['ttl_change']
     | merged inputs:  ['p__br_tmp6', 'p_ttl', 'p_seen00', 'ttl_change']
		| merged state vars:  {'ttl_change', 'last_ttl'}
		| merged stateless vars:  ['p__br_tmp6', 'p_ttl', 'p_seen00']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl', 'ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['p__br_tmp5', 'last_ttl']
 node inputs:  ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl']
 exclude_read_write_flanks: successor inputs:  {'ttl_change', 'p__br_tmp5', 'p__br_tmp6'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl', 'ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['p_ttl', 'last_ttl']
		| merged state vars:  {'last_ttl', 'seen'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen01', 'p_seen00']
 | state_pkt_fields of component b:  ['p_last_ttl02', 'p_last_ttl00']
merge component: component is ----  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7fb32d9fe5b0>, <dependencyGraph.Statement object at 0x7fb32d9fe100>, <dependencyGraph.Statement object at 0x7fb32d9fe520>, <dependencyGraph.Statement object at 0x7fb32d9fe370>, <dependencyGraph.Statement object at 0x7fb32d9fe4f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_last_ttl00', 'p_last_ttl01', 'p_last_ttl02', 'p_seen01', 'p_seen00']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['p__br_tmp6', 'seen', 'p__br_tmp5', 'last_ttl']
new component state_pkt_fields:  ['p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_4_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_4_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_4_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p__br_tmp6', 'p_seen00', 'seen']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp6', 'last_ttl', 'p_seen00', 'p_ttl'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p__br_tmp6', 'p_seen00', 'seen']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp6', 'p_ttl', 'p_seen00', 'p__br_tmp5', 'ttl_change', 'last_ttl'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl']
 problematic state vars:  ['last_ttl']
preprocessor time:
running mutation 5
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_5. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp5 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp6 = p_seen00==0;

lhs p__br_tmp6 rhs p_seen00==0
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p__br_tmp6 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp6 ? (1) : (p_seen00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_seen00']
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp6 ? (0) : (p_ttl_change01)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp6 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp6 = p_seen00==0; p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp6 = p_seen00==0; p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'ttl_change': {'read': <dependencyGraph.Statement object at 0x7f6b6d89b580>, 'write': <dependencyGraph.Statement object at 0x7f6b6d89b400>}, 'seen': {'read': <dependencyGraph.Statement object at 0x7f6b6d89b160>, 'write': <dependencyGraph.Statement object at 0x7f6b6d89b1f0>}, 'last_ttl': {'read': <dependencyGraph.Statement object at 0x7f6b6d89b5b0>, 'write': <dependencyGraph.Statement object at 0x7f6b6d89b4f0>}}
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7f6b6d89b580>, 'write': <dependencyGraph.Statement object at 0x7f6b6d89b400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  seen
{'read': <dependencyGraph.Statement object at 0x7f6b6d89b160>, 'write': <dependencyGraph.Statement object at 0x7f6b6d89b1f0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7f6b6d89b5b0>, 'write': <dependencyGraph.Statement object at 0x7f6b6d89b4f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp6 = p_seen00==0 stmts len 1
p__br_tmp6 = p_seen00==0;
v p_seen01 = p__br_tmp6 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f6b6d89bc70>, <dependencyGraph.Codelet object at 0x7f6b6d89bdf0>, <dependencyGraph.Codelet object at 0x7f6b6d89bbb0>, <dependencyGraph.Codelet object at 0x7f6b6d89bd90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp6 = p_seen00==0;
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f6b6d89bdf0>, <dependencyGraph.Codelet object at 0x7f6b6d89bbb0>, <dependencyGraph.Codelet object at 0x7f6b6d89bc70>}
total number of nodes created:  4
state vars {'ttl_change', 'seen', 'last_ttl'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp5'}
elements in v_outputs:  {'p__br_tmp5'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp5'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
p__br_tmp5  not in state vars
 statement:  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp5'}
   - createing a node for flank  p__br_tmp5
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p_seen00', 'p__br_tmp6'}
p_seen00  is read flank
elements in v_outputs:  {'p_seen00', 'p__br_tmp6'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp6'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp6 = p_seen00==0
2   p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
3   seen = p_seen01
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
p__br_tmp6  not in state vars
 statement:  p__br_tmp6 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp6', 'p_seen00']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p_seen00', 'p__br_tmp6'}
   - createing a node for flank  p__br_tmp6
   - createing a node for flank  p_seen00
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_5_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_5_out
Stored read, write flank variables
{'p_ttl_change02', 'p_seen00', 'p_ttl_change00', 'p_last_ttl00', 'p_last_ttl02', 'p_seen01'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['p_ttl_change01', 'ttl_change', 'p_ttl_change00', 'p_ttl_change02']
 node inputs:  ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_last_ttl00', 'p_last_ttl01', 'p_last_ttl02']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change01', 'p_ttl_change00', 'p_ttl_change02']
state_var ['ttl_change']
     | merged inputs:  ['p_seen00', 'p_ttl', 'p__br_tmp6', 'ttl_change']
		| merged state vars:  {'ttl_change', 'last_ttl'}
		| merged stateless vars:  ['p_seen00', 'p_ttl', 'p__br_tmp6']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl', 'ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['p__br_tmp5', 'last_ttl']
 node inputs:  ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp5', 'p__br_tmp6', 'ttl_change'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['p_ttl', 'last_ttl']
		| merged state vars:  {'seen', 'last_ttl'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen00', 'p_seen01']
 | state_pkt_fields of component b:  ['p_last_ttl00', 'p_last_ttl02']
merge component: component is ----  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f6b6d89b5b0>, <dependencyGraph.Statement object at 0x7f6b6d89b100>, <dependencyGraph.Statement object at 0x7f6b6d89b520>, <dependencyGraph.Statement object at 0x7f6b6d89b370>, <dependencyGraph.Statement object at 0x7f6b6d89b4f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs ['p_seen00', 'p_last_ttl00', 'p_last_ttl01', 'p_last_ttl02', 'p_seen01']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['seen', 'last_ttl', 'p__br_tmp6', 'p__br_tmp5']
new component state_pkt_fields:  ['p_seen00', 'p_seen01', 'p_last_ttl00', 'p_last_ttl02']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_5_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_5_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_5_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl', 'ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp5']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['seen', 'p_seen00', 'p__br_tmp6']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'p_ttl', 'last_ttl', 'p__br_tmp6', 'p__br_tmp5', 'ttl_change'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['seen', 'p_seen00', 'p__br_tmp6']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_ttl', 'p_seen00', 'p__br_tmp6', 'last_ttl'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p__br_tmp6', 'p_seen00', 'p_ttl']
 problematic state vars:  ['last_ttl']
preprocessor time:
running mutation 6
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_6. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp9 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp9 ? (p_ttl) : (p_last_ttl00)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp9', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp9', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp11 = p_seen00==0;

lhs p__br_tmp11 rhs p_seen00==0
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p__br_tmp11 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp11 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp11 ? (1) : (p_seen00)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_seen01 = p__br_tmp11 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp11', 'p_seen00']
p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp11 ? (p_ttl) : (p_last_ttl01)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp11', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp11 ? (0) : (p_ttl_change01)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp11', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp11 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp11 ? (1) : (p_seen00);
RAW p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01);
RAW p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00);
RAW p__br_tmp11 = p_seen00==0; p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp11 = p_seen00==0; p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'seen': {'read': <dependencyGraph.Statement object at 0x7fc111f61160>, 'write': <dependencyGraph.Statement object at 0x7fc111f611f0>}, 'ttl_change': {'read': <dependencyGraph.Statement object at 0x7fc111f61580>, 'write': <dependencyGraph.Statement object at 0x7fc111f61400>}, 'last_ttl': {'read': <dependencyGraph.Statement object at 0x7fc111f615b0>, 'write': <dependencyGraph.Statement object at 0x7fc111f614f0>}}
var:  seen
{'read': <dependencyGraph.Statement object at 0x7fc111f61160>, 'write': <dependencyGraph.Statement object at 0x7fc111f611f0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7fc111f61580>, 'write': <dependencyGraph.Statement object at 0x7fc111f61400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7fc111f615b0>, 'write': <dependencyGraph.Statement object at 0x7fc111f614f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp11 = p_seen00==0 stmts len 1
p__br_tmp11 = p_seen00==0;
v p_seen01 = p__br_tmp11 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp11 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7fc111f61c70>, <dependencyGraph.Codelet object at 0x7fc111f61df0>, <dependencyGraph.Codelet object at 0x7fc111f61bb0>, <dependencyGraph.Codelet object at 0x7fc111f61d90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp11 = p_seen00==0;
p_seen01 = p__br_tmp11 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7fc111f61df0>, <dependencyGraph.Codelet object at 0x7fc111f61bb0>, <dependencyGraph.Codelet object at 0x7fc111f61c70>}
total number of nodes created:  4
state vars {'seen', 'ttl_change', 'last_ttl'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp9'}
elements in v_outputs:  {'p__br_tmp9'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp9'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp11', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp9', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
p__br_tmp9  not in state vars
 statement:  p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp9'}
   - createing a node for flank  p__br_tmp9
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p_seen00', 'p__br_tmp11'}
p_seen00  is read flank
elements in v_outputs:  {'p_seen00', 'p__br_tmp11'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp11'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp11 = p_seen00==0
2   p_seen01 = p__br_tmp11 ? (1) : (p_seen00)
3   seen = p_seen01
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
p__br_tmp11  not in state vars
 statement:  p__br_tmp11 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp11 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp11', 'p_seen00']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p_seen00', 'p__br_tmp11'}
   - createing a node for flank  p__br_tmp11
   - createing a node for flank  p_seen00
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_6_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_6_out
Stored read, write flank variables
{'p_ttl_change00', 'p_ttl_change02', 'p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl00'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp11 = p_seen00==0 p_seen01 = p__br_tmp11 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp11 = p_seen00==0 p_seen01 = p__br_tmp11 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp11 = p_seen00==0 p_seen01 = p__br_tmp11 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp11 = p_seen00==0 p_seen01 = p__br_tmp11 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp11 = p_seen00==0 p_seen01 = p__br_tmp11 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['ttl_change', 'p_ttl_change02', 'p_ttl_change00', 'p_ttl_change01']
 node inputs:  ['ttl_change', 'p__br_tmp9', 'p__br_tmp11']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp9', 'p__br_tmp11']
redundant outputs ['p_last_ttl02', 'p_last_ttl01', 'p_last_ttl00']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change02', 'p_ttl_change00', 'p_ttl_change01']
state_var ['ttl_change']
     | merged inputs:  ['ttl_change', 'p_seen00', 'p_ttl', 'p__br_tmp11']
		| merged state vars:  {'ttl_change', 'last_ttl'}
		| merged stateless vars:  ['p_seen00', 'p_ttl', 'p__br_tmp11']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp11', 'ttl_change', 'p__br_tmp9', 'p__br_tmp11']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['last_ttl', 'p__br_tmp9']
 node inputs:  ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp11']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp9', 'ttl_change', 'p__br_tmp11'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp11']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp9', 'p__br_tmp11']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['last_ttl', 'p_ttl']
		| merged state vars:  {'seen', 'last_ttl'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen00', 'p_seen01']
 | state_pkt_fields of component b:  ['p_last_ttl02', 'p_last_ttl00']
merge component: component is ----  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7fc111f615b0>, <dependencyGraph.Statement object at 0x7fc111f61100>, <dependencyGraph.Statement object at 0x7fc111f61520>, <dependencyGraph.Statement object at 0x7fc111f61370>, <dependencyGraph.Statement object at 0x7fc111f614f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp9', 'p__br_tmp11']
redundant outputs ['p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl01', 'p_last_ttl00']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['seen', 'last_ttl', 'p__br_tmp9', 'p__br_tmp11']
new component state_pkt_fields:  ['p_seen00', 'p_seen01', 'p_last_ttl02', 'p_last_ttl00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_6_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_6_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_6_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp11', 'ttl_change', 'p__br_tmp9', 'p__br_tmp11']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp9', 'p__br_tmp11']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p_seen00', 'seen', 'p__br_tmp11']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'last_ttl', 'ttl_change', 'p_seen00', 'p__br_tmp9', 'p_ttl', 'p__br_tmp11'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p_seen00', 'seen', 'p__br_tmp11']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'last_ttl', 'p_ttl', 'p__br_tmp11'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp11 = p_seen00==0; p_seen01 = p__br_tmp11 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp9 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp11 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp11']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp9 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp9 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp11 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp11']
 problematic state vars:  ['last_ttl']
preprocessor time:
running mutation 7
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_7. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp6 = p_seen00==0;

lhs p__br_tmp6 rhs p_seen00==0
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p__br_tmp6 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp6 ? (1) : (p_seen00)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_seen00']
p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp6 ? (p_ttl) : (p_last_ttl00)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp6 ? (0) : (p_ttl_change00)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl_change00']
p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl);

lhs p__br_tmp7 rhs (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_seen01', 'p_last_ttl01', 'p_ttl']
p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp7 ? (p_ttl) : (p_last_ttl01)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp7', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01)
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp7', 'p_ttl_change01', 'p_ttl_change01']
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'ttl_change', 'last_ttl', 'seen'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
finding dependencies
RAW p_seen00 = seen; p__br_tmp6 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p_seen00 = seen; p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00);
RAW p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp6 = p_seen00==0; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp6 = p_seen00==0; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00);
RAW p_seen01 = p__br_tmp6 ? (1) : (p_seen00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl);
RAW p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl);
RAW p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01);
RAW p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01);
RAW p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'ttl_change': {'read': <dependencyGraph.Statement object at 0x7f178bfb0040>, 'write': <dependencyGraph.Statement object at 0x7f178bfb0250>}, 'last_ttl': {'read': <dependencyGraph.Statement object at 0x7f178bfb0580>, 'write': <dependencyGraph.Statement object at 0x7f178bfb0400>}, 'seen': {'read': <dependencyGraph.Statement object at 0x7f178bfb05b0>, 'write': <dependencyGraph.Statement object at 0x7f178bfb00d0>}}
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7f178bfb0040>, 'write': <dependencyGraph.Statement object at 0x7f178bfb0250>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7f178bfb0580>, 'write': <dependencyGraph.Statement object at 0x7f178bfb0400>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
var:  seen
{'read': <dependencyGraph.Statement object at 0x7f178bfb05b0>, 'write': <dependencyGraph.Statement object at 0x7f178bfb00d0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00);
v p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl) stmts len 1
p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl);
v p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp6 = p_seen00==0 stmts len 1
p__br_tmp6 = p_seen00==0;
v p_seen01 = p__br_tmp6 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f178bfb0d00>, <dependencyGraph.Codelet object at 0x7f178bfb0df0>, <dependencyGraph.Codelet object at 0x7f178bfb0d90>, <dependencyGraph.Codelet object at 0x7f178bfb0c70>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00);
p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl);
p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp6 = p_seen00==0;
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f178bfb0d00>, <dependencyGraph.Codelet object at 0x7f178bfb0d90>, <dependencyGraph.Codelet object at 0x7f178bfb0df0>}
total number of nodes created:  4
state vars {'ttl_change', 'last_ttl', 'seen'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp7'}
elements in v_outputs:  {'p__br_tmp7'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp7'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00)
2   p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl)
3   p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp7', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
p__br_tmp7  not in state vars
 statement:  p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_seen01', 'p_last_ttl01', 'p_ttl']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp6', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp7'}
   - createing a node for flank  p__br_tmp7
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p_seen01', 'p_seen00', 'p__br_tmp6'}
p_seen01  is write flank
p_seen00  is read flank
elements in v_outputs:  {'p_seen01', 'p_seen00', 'p__br_tmp6'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp6'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp6 = p_seen00==0
2   p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
3   seen = p_seen01
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp6', 'p_seen00']
 state vars:  ['seen']
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
p__br_tmp6  not in state vars
 statement:  p__br_tmp6 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen01    read_flanks:  []   write_flanks:  ['p_seen01']
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p_seen01', 'p_seen00', 'p__br_tmp6'}
   - createing a node for flank  p_seen00
   - createing a node for flank  p__br_tmp6
   - createing a node for flank  p_seen01
size of SCC graph post-duplicate:  6
number of SCC nodes post splitting:  6
total number of nodes created:  6
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out
Stored read, write flank variables
{'p_ttl_change00', 'p_last_ttl02', 'p_ttl_change02', 'p_seen00', 'p_seen01', 'p_last_ttl00'}
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00) p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_4 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00) p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl) p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_last_ttl00 = last_ttl p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00) p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl) p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  6
number of nodes in comp_graph:  6
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['p_ttl_change00', 'ttl_change', 'p_ttl_change01', 'p_ttl_change02']
 node inputs:  ['ttl_change', 'p__br_tmp6', 'p__br_tmp7']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp7']
redundant outputs ['p_last_ttl02', 'p_last_ttl01', 'p_last_ttl00']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change00', 'p_ttl_change01', 'p_ttl_change02']
state_var ['ttl_change']
     | merged inputs:  ['p_seen00', 'ttl_change', 'p_ttl', 'p__br_tmp6', 'p_seen01']
		| merged state vars:  {'ttl_change', 'last_ttl'}
		| merged stateless vars:  ['p_seen00', 'p_ttl', 'p__br_tmp6', 'p_seen01']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp7', 'last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp6', 'p_seen01']
redundant outputs []
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['p__br_tmp7', 'last_ttl']
 node inputs:  ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp6', 'p_seen01']
 exclude_read_write_flanks: successor inputs:  {'ttl_change', 'p__br_tmp6', 'p__br_tmp7'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp6', 'p_seen01']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp7']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['p_ttl', 'last_ttl']
		| merged state vars:  {'last_ttl', 'seen'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen01', 'p_seen00']
 | state_pkt_fields of component b:  ['p_last_ttl02', 'p_last_ttl00']
merge component: component is ----  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f178bfb0580>, <dependencyGraph.Statement object at 0x7f178bfb06d0>, <dependencyGraph.Statement object at 0x7f178bfb0520>, <dependencyGraph.Statement object at 0x7f178bfb0280>, <dependencyGraph.Statement object at 0x7f178bfb0400>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp7']
redundant outputs ['p_seen00', 'p_last_ttl02', 'p_last_ttl01', 'p_seen01', 'p_last_ttl00']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['p__br_tmp7', 'seen', 'p__br_tmp6', 'last_ttl']
new component state_pkt_fields:  ['p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  6
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp6', 'p_seen01']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp7']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['p_ttl', 'last_ttl']
		| merged state vars:  {'last_ttl', 'seen'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen01', 'p_seen00']
 | state_pkt_fields of component b:  ['p_last_ttl02', 'p_last_ttl00']
merge component: component is ----  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f178bfb0580>, <dependencyGraph.Statement object at 0x7f178bfb06d0>, <dependencyGraph.Statement object at 0x7f178bfb0520>, <dependencyGraph.Statement object at 0x7f178bfb0280>, <dependencyGraph.Statement object at 0x7f178bfb0400>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp7']
redundant outputs ['p_seen00', 'p_last_ttl02', 'p_last_ttl01', 'p_seen01', 'p_last_ttl00']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['p__br_tmp7', 'seen', 'p__br_tmp6', 'last_ttl']
new component state_pkt_fields:  ['p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/try_merge_query_1_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/try_merge_query_1_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/try_merge_query_1_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  6
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp7', 'last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp6', 'p_seen01']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp6', 'p__br_tmp7']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p_seen01', 'p_seen00', 'seen', 'p__br_tmp6']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'p_ttl', 'p__br_tmp6', 'last_ttl', 'p_seen01'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen01', 'p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p_seen01', 'p_seen00', 'seen', 'p__br_tmp6']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'p_ttl', 'p__br_tmp6', 'last_ttl', 'p_seen01'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen01', 'p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p_seen01', 'p_seen00', 'seen', 'p__br_tmp6']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'ttl_change', 'p_ttl', 'p__br_tmp7', 'p__br_tmp6', 'last_ttl', 'p_seen01'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen01', 'p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00); p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
~~~~~~~~~~set_alu_inputs:  ['seen']
 ~~~| state var:  ['seen']
salu_inputs {'metadata_lo': 0, 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 0}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_0_stateful.sk
return code 0
solved
output is in /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_0_stateful.sk.out
 find_output_dst: reading from sketch file  /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_0_stateful.sk
find_output_dst: trying to find `void comp_0`
done
curr line: 	int[3] _out;

curr line: 	int p_seen01;

curr line: 	int p_seen00;

curr line: 	bit p__br_tmp6;

curr line: 	p_seen00 = seen;

curr line: 	p__br_tmp6 = p_seen00==0;

curr line: 	p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

curr line: 	seen = p_seen01;

curr line: 	_out[0] = seen;

 > FOUND OUT LINE : 	_out[0] = seen;

curr line: 	_out[1] = 0;

 > FOUND OUT LINE : 	_out[1] = 0;

curr line: 	_out[2] = p__br_tmp6;

 > FOUND OUT LINE : 	_out[2] = p__br_tmp6;

> found out variable:  p__br_tmp6
curr line: 	return _out;

curr line: }

done ---- outs[-1] is  p__br_tmp6
Constructing new SALU: id= 0  metadata_lo= 0  metadata_hi= 0  register_lo= seen  register_hi= 0  output_dst= p__br_tmp6
demangled line:  _out0 = ( ( int [ 3 ] ) 0 )
demangled line:  int register_hi = register_hi
demangled line:  int register_lo = register_lo
demangled line:  int update_hi_1_value = 0
demangled line:  compute_alu ( 1 1 register_lo update_hi_1_value )
process_salu_function: parsing compute_alu   compute_alu(1, 1, register_lo_0, update_hi_1_value_s13)//{};

demangled line:  int update_hi_2_value = 0
demangled line:  compute_alu ( 2 30 31 update_hi_2_value )
process_salu_function: parsing compute_alu   compute_alu(2, 30, 31, update_hi_2_value_s23)//{};

demangled line:  int update_lo_1_value = 0
demangled line:  compute_alu ( 7 metadata_lo 11 update_lo_1_value )
process_salu_function: parsing compute_alu   compute_alu(7, metadata_lo, 11, update_lo_1_value_s33)//{};

demangled line:  int update_lo_2_value = 0
demangled line:  compute_alu ( 2 15 register_lo update_lo_2_value )
process_salu_function: parsing compute_alu   compute_alu(2, 15, register_lo_0, update_lo_2_value_s43)//{};

demangled line:  bit condition_hi = ( ( metadata_lo - register_lo ) + 1 ) < 0
process_salu_function: parsing  condition_hi ; rhs =  ((metadata_lo-register_lo)+1)<0
    ( line =    bit condition_hi_s55 = ((metadata_lo - register_lo_0) + 1) < 0;
  )
demangled line:  bit condition_lo = ( ( metadata_lo + register_hi ) + 1 ) < 0
process_salu_function: parsing  condition_lo ; rhs =  ((metadata_lo+register_hi)+1)<0
    ( line =    bit condition_lo_s67 = ((metadata_lo + register_hi_1) + 1) < 0;
  )
demangled line:  bit update_hi_1_predicate = 0
demangled line:  bool_op ( 1 condition_hi condition_lo update_hi_1_predicate )
process_salu_function: parsing bool_op   bool_op(1, condition_hi_s55, condition_lo_s67, update_hi_1_predicate_s69);

 | -> eval_bool_op: op1  condition_hi  ; op2  condition_lo  ; opcode:  1
PARSING BOOL_OP <---------------------- LHS:  update_hi_1_predicate  | RHS:  !((condition_hi) || (condition_lo))
demangled line:  bit update_hi_2_predicate = 0
demangled line:  bool_op ( 6 condition_hi condition_lo update_hi_2_predicate )
process_salu_function: parsing bool_op   bool_op(6, condition_hi_s55, condition_lo_s67, update_hi_2_predicate_s71);

 | -> eval_bool_op: op1  condition_hi  ; op2  condition_lo  ; opcode:  6
PARSING BOOL_OP <---------------------- LHS:  update_hi_2_predicate  | RHS:  (condition_hi) && (condition_lo)
demangled line:  bit update_lo_1_predicate = 0
demangled line:  bool_op ( 1 condition_hi condition_lo update_lo_1_predicate )
process_salu_function: parsing bool_op   bool_op(1, condition_hi_s55, condition_lo_s67, update_lo_1_predicate_s73);

 | -> eval_bool_op: op1  condition_hi  ; op2  condition_lo  ; opcode:  1
PARSING BOOL_OP <---------------------- LHS:  update_lo_1_predicate  | RHS:  !((condition_hi) || (condition_lo))
demangled line:  bit update_lo_2_predicate = 0
demangled line:  bool_op ( 0 condition_hi condition_lo update_lo_2_predicate )
process_salu_function: parsing bool_op   bool_op(0, condition_hi_s55, condition_lo_s67, update_lo_2_predicate_s75);

 | -> eval_bool_op: op1  condition_hi  ; op2  condition_lo  ; opcode:  0
PARSING BOOL_OP <---------------------- LHS:  update_lo_2_predicate  | RHS:  false
demangled line:  assert ( ! ( update_hi_1_predicate && update_hi_2_predicate ) )
Illegal character '/'
Illegal character '/'
demangled line:  if ( update_hi_1_predicate && ( ! ( update_hi_2_predicate ) ) ) * comp_0_..ateful.sk : 195 *
demangled line:  {
demangled line:  register_hi = update_hi_1_value
demangled line:  }
demangled line:  else
demangled line:  {
Illegal character '/'
Illegal character '/'
demangled line:  if ( ( ! ( update_hi_1_predicate ) ) && update_hi_2_predicate ) * comp_0_..ateful.sk : 197 *
demangled line:  {
demangled line:  register_hi = update_hi_2_value
demangled line:  }
demangled line:  else
demangled line:  {
demangled line:  register_hi = register_hi
demangled line:  }
demangled line:  }
demangled line:  assert ( ! ( update_lo_1_predicate && update_lo_2_predicate ) )
Illegal character '/'
Illegal character '/'
demangled line:  if ( update_lo_1_predicate && ( ! ( update_lo_2_predicate ) ) ) * comp_0_..ateful.sk : 206 *
demangled line:  {
demangled line:  register_lo = update_lo_1_value
demangled line:  }
demangled line:  else
demangled line:  {
Illegal character '/'
Illegal character '/'
demangled line:  if ( ( ! ( update_lo_1_predicate ) ) && update_lo_2_predicate ) * comp_0_..ateful.sk : 208 *
demangled line:  {
demangled line:  register_lo = update_lo_2_value
demangled line:  }
demangled line:  else
demangled line:  {
demangled line:  register_lo = register_lo
demangled line:  }
demangled line:  }
demangled line:  _out0 [ 0 ] = register_lo
demangled line:  _out0 [ 1 ] = 0
output_value found, is  0
demangled line:  _out0 [ 2 ] = register_hi
demangled line:  return
filename_to_compname: filename =  comp_0_stateful.sk.out
['comp_0']
>>>>>>>>>> add_new_alu: adding ALU with id  0  and component  comp_0 , type?  STATEFUL
filename_to_compname: filename =  comp_0_stateful.sk.out
['comp_0']
~~~~~~~~~~set_alu_inputs:  ['ttl_change', 'p__br_tmp6', 'p__br_tmp7']
 ~~~| state var:  ['ttl_change']
salu_inputs {'metadata_lo': 'p__br_tmp6', 'metadata_hi': 'p__br_tmp7', 'register_lo': 'ttl_change', 'register_hi': 0}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_1_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_1_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_1_stateful.sk
return code 0
solved
output is in /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_1_stateful.sk.out
 find_output_dst: reading from sketch file  /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_7_out/comp_1_stateful.sk
find_output_dst: trying to find `void comp_1`
done
curr line: 	int[3] _out;

curr line: 	int p_ttl_change00;

curr line: 	int p_ttl_change01;

curr line: 	int p_ttl_change02;

curr line: 	p_ttl_change00 = ttl_change;

curr line: 	p_ttl_change01 = p__br_tmp6 ? (0) : (p_ttl_change00);

curr line: 	p_ttl_change02 = p__br_tmp7 ? (1+p_ttl_change01) : (p_ttl_change01);

curr line: 	ttl_change = p_ttl_change02;

curr line: 	_out[0] = ttl_change;

 > FOUND OUT LINE : 	_out[0] = ttl_change;

curr line: 	_out[1] = 0;

 > FOUND OUT LINE : 	_out[1] = 0;

curr line: 	_out[2] = 0;

 > FOUND OUT LINE : 	_out[2] = 0;

> found out variable:  0
curr line: 	return _out;

curr line: }

done ---- outs[-1] is  0
Constructing new SALU: id= 1  metadata_lo= p__br_tmp6  metadata_hi= p__br_tmp7  register_lo= ttl_change  register_hi= 0  output_dst= 0
demangled line:  _out0 = ( ( int [ 3 ] ) 0 )
demangled line:  int register_hi = register_hi
demangled line:  int register_lo = register_lo
demangled line:  int update_hi_1_value = 0
demangled line:  compute_alu ( 7 15 14 update_hi_1_value )
process_salu_function: parsing compute_alu   compute_alu(7, 15, 14, update_hi_1_value_s13)//{};

demangled line:  int update_hi_2_value = 0
demangled line:  compute_alu ( 2 0 31 update_hi_2_value )
process_salu_function: parsing compute_alu   compute_alu(2, 0, 31, update_hi_2_value_s23)//{};

demangled line:  int update_lo_1_value = 0
demangled line:  compute_alu ( 0 metadata_hi register_lo update_lo_1_value )
process_salu_function: parsing compute_alu   compute_alu(0, metadata_hi, register_lo_0, update_lo_1_value_s33)//{};

demangled line:  int update_lo_2_value = 0
demangled line:  compute_alu ( 4 metadata_hi 4 update_lo_2_value )
process_salu_function: parsing compute_alu   compute_alu(4, metadata_hi, 4, update_lo_2_value_s43)//{};

demangled line:  bit condition_hi = ( ( 0 - metadata_lo ) - register_lo ) == 0
process_salu_function: parsing  condition_hi ; rhs =  ((0-metadata_lo)-register_lo)==0
    ( line =    bit condition_hi_s55 = ((0 - metadata_lo) - register_lo_0) == 0;
  )
demangled line:  bit condition_lo = ( ( ( 0 - metadata_lo ) + register_hi ) + 1 ) > 0
process_salu_function: parsing  condition_lo ; rhs =  (((0-metadata_lo)+register_hi)+1)>0
    ( line =    bit condition_lo_s67 = (((0 - metadata_lo) + register_hi_1) + 1) > 0;
  )
demangled line:  bit update_hi_1_predicate = 0
demangled line:  bool_op ( 4 condition_hi condition_lo update_hi_1_predicate )
process_salu_function: parsing bool_op   bool_op(4, condition_hi_s55, condition_lo_s67, update_hi_1_predicate_s69);

 | -> eval_bool_op: op1  condition_hi  ; op2  condition_lo  ; opcode:  4
PARSING BOOL_OP <---------------------- LHS:  update_hi_1_predicate  | RHS:  (condition_hi) && (!(condition_lo))
demangled line:  bit update_hi_2_predicate = 0
demangled line:  bool_op ( 4 condition_hi condition_lo update_hi_2_predicate )
process_salu_function: parsing bool_op   bool_op(4, condition_hi_s55, condition_lo_s67, update_hi_2_predicate_s71);

 | -> eval_bool_op: op1  condition_hi  ; op2  condition_lo  ; opcode:  4
PARSING BOOL_OP <---------------------- LHS:  update_hi_2_predicate  | RHS:  (condition_hi) && (!(condition_lo))
demangled line:  bit update_lo_1_predicate = 0
demangled line:  bool_op ( 10 condition_hi condition_lo update_lo_1_predicate )
process_salu_function: parsing bool_op   bool_op(10, condition_hi_s55, condition_lo_s67, update_lo_1_predicate_s73);

 | -> eval_bool_op: op1  condition_hi  ; op2  condition_lo  ; opcode:  10
PARSING BOOL_OP <---------------------- LHS:  update_lo_1_predicate  | RHS:  (condition_lo)
demangled line:  bit update_lo_2_predicate = 0
demangled line:  bool_op ( 1 condition_hi condition_lo update_lo_2_predicate )
process_salu_function: parsing bool_op   bool_op(1, condition_hi_s55, condition_lo_s67, update_lo_2_predicate_s75);

 | -> eval_bool_op: op1  condition_hi  ; op2  condition_lo  ; opcode:  1
PARSING BOOL_OP <---------------------- LHS:  update_lo_2_predicate  | RHS:  !((condition_hi) || (condition_lo))
demangled line:  assert ( ! ( update_hi_1_predicate && update_hi_2_predicate ) )
Illegal character '/'
Illegal character '/'
demangled line:  if ( update_hi_1_predicate && ( ! ( update_hi_2_predicate ) ) ) * comp_1_..ateful.sk : 195 *
demangled line:  {
demangled line:  register_hi = update_hi_1_value
demangled line:  }
demangled line:  else
demangled line:  {
Illegal character '/'
Illegal character '/'
demangled line:  if ( ( ! ( update_hi_1_predicate ) ) && update_hi_2_predicate ) * comp_1_..ateful.sk : 197 *
demangled line:  {
demangled line:  register_hi = update_hi_2_value
demangled line:  }
demangled line:  else
demangled line:  {
demangled line:  register_hi = register_hi
demangled line:  }
demangled line:  }
demangled line:  assert ( ! ( update_lo_1_predicate && update_lo_2_predicate ) )
Illegal character '/'
Illegal character '/'
demangled line:  if ( update_lo_1_predicate && ( ! ( update_lo_2_predicate ) ) ) * comp_1_..ateful.sk : 206 *
demangled line:  {
demangled line:  register_lo = update_lo_1_value
demangled line:  }
demangled line:  else
demangled line:  {
Illegal character '/'
Illegal character '/'
demangled line:  if ( ( ! ( update_lo_1_predicate ) ) && update_lo_2_predicate ) * comp_1_..ateful.sk : 208 *
demangled line:  {
demangled line:  register_lo = update_lo_2_value
demangled line:  }
demangled line:  else
demangled line:  {
demangled line:  register_lo = register_lo
demangled line:  }
demangled line:  }
demangled line:  _out0 [ 0 ] = register_lo
demangled line:  _out0 [ 1 ] = register_hi
output_value found, is  register_hi
demangled line:  _out0 [ 2 ] = 0
demangled line:  return
filename_to_compname: filename =  comp_1_stateful.sk.out
['comp_1']
>>>>>>>>>> add_new_alu: adding ALU with id  1  and component  comp_1 , type?  STATEFUL
filename_to_compname: filename =  comp_1_stateful.sk.out
['comp_1']
Error: stateful update does not fit in the stateful ALU.
node:  p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp6 ? (p_ttl) : (p_last_ttl00); p__br_tmp7 = (!(p_seen00==0))&&(!(p_seen01==0))&&(p_last_ttl01!=p_ttl); p_last_ttl02 = p__br_tmp7 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
inputs:  ['last_ttl', 'p_seen00', 'p_ttl', 'p__br_tmp6', 'p_seen01']
outputs:  ['p__br_tmp7', 'last_ttl']
preprocessor time:
running mutation 8
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_8. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp5 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp6 = p_seen00==0;

lhs p__br_tmp6 rhs p_seen00==0
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p__br_tmp6 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp6 ? (1) : (p_seen00)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_seen00']
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp6 ? (0) : (p_ttl_change01)
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'seen', 'ttl_change', 'last_ttl'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp6 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp6 = p_seen00==0; p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp6 = p_seen00==0; p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'seen': {'read': <dependencyGraph.Statement object at 0x7f4bd64c8040>, 'write': <dependencyGraph.Statement object at 0x7f4bd64c8250>}, 'ttl_change': {'read': <dependencyGraph.Statement object at 0x7f4bd64c8580>, 'write': <dependencyGraph.Statement object at 0x7f4bd64c8400>}, 'last_ttl': {'read': <dependencyGraph.Statement object at 0x7f4bd64c85b0>, 'write': <dependencyGraph.Statement object at 0x7f4bd64c84f0>}}
var:  seen
{'read': <dependencyGraph.Statement object at 0x7f4bd64c8040>, 'write': <dependencyGraph.Statement object at 0x7f4bd64c8250>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7f4bd64c8580>, 'write': <dependencyGraph.Statement object at 0x7f4bd64c8400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7f4bd64c85b0>, 'write': <dependencyGraph.Statement object at 0x7f4bd64c84f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp6 = p_seen00==0 stmts len 1
p__br_tmp6 = p_seen00==0;
v p_seen01 = p__br_tmp6 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f4bd64c8c70>, <dependencyGraph.Codelet object at 0x7f4bd64c8df0>, <dependencyGraph.Codelet object at 0x7f4bd64c8bb0>, <dependencyGraph.Codelet object at 0x7f4bd64c8d90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp6 = p_seen00==0;
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f4bd64c8df0>, <dependencyGraph.Codelet object at 0x7f4bd64c8bb0>, <dependencyGraph.Codelet object at 0x7f4bd64c8c70>}
total number of nodes created:  4
state vars {'seen', 'ttl_change', 'last_ttl'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp5'}
elements in v_outputs:  {'p__br_tmp5'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp5'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p__br_tmp5  not in state vars
 statement:  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp5'}
   - createing a node for flank  p__br_tmp5
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p__br_tmp6', 'p_seen00'}
p_seen00  is read flank
elements in v_outputs:  {'p__br_tmp6', 'p_seen00'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp6'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp6 = p_seen00==0
2   p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
3   seen = p_seen01
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp6', 'p_seen00']
 state vars:  ['seen']
p__br_tmp6  not in state vars
 statement:  p__br_tmp6 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p__br_tmp6', 'p_seen00'}
   - createing a node for flank  p_seen00
   - createing a node for flank  p__br_tmp6
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_8_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_8_out
Stored read, write flank variables
{'p_seen00', 'p_ttl_change00', 'p_seen01', 'p_ttl_change02', 'p_last_ttl02', 'p_last_ttl00'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['p_ttl_change00', 'ttl_change', 'p_ttl_change02', 'p_ttl_change01']
 node inputs:  ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_last_ttl02', 'p_last_ttl01', 'p_last_ttl00']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change00', 'p_ttl_change02', 'p_ttl_change01']
state_var ['ttl_change']
     | merged inputs:  ['p_seen00', 'p_ttl', 'p__br_tmp6', 'ttl_change']
		| merged state vars:  {'ttl_change', 'last_ttl'}
		| merged stateless vars:  ['p_seen00', 'p_ttl', 'p__br_tmp6']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00', 'ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['p__br_tmp5', 'last_ttl']
 node inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp5', 'p__br_tmp6', 'ttl_change'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00', 'ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['last_ttl', 'p_ttl']
		| merged state vars:  {'seen', 'last_ttl'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen01', 'p_seen00']
 | state_pkt_fields of component b:  ['p_last_ttl02', 'p_last_ttl00']
merge component: component is ----  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f4bd64c85b0>, <dependencyGraph.Statement object at 0x7f4bd64c8190>, <dependencyGraph.Statement object at 0x7f4bd64c8520>, <dependencyGraph.Statement object at 0x7f4bd64c8370>, <dependencyGraph.Statement object at 0x7f4bd64c84f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_seen00', 'p_seen01', 'p_last_ttl02', 'p_last_ttl00', 'p_last_ttl01']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['seen', 'p__br_tmp5', 'last_ttl', 'p__br_tmp6']
new component state_pkt_fields:  ['p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_8_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_8_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_8_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['seen', 'p__br_tmp6', 'p_seen00']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_ttl', 'p__br_tmp6', 'last_ttl', 'p_seen00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['seen', 'p__br_tmp6', 'p_seen00']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_seen00', 'p__br_tmp5', 'last_ttl', 'p_ttl', 'p__br_tmp6', 'ttl_change'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 problematic state vars:  ['last_ttl']
preprocessor time:
running mutation 9
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_9. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp3 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp3 ? (p_ttl) : (p_last_ttl00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp3', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp3', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp4 = p_seen00==0;

lhs p__br_tmp4 rhs p_seen00==0
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p__br_tmp4 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp4 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp4 ? (1) : (p_seen00)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_seen01 = p__br_tmp4 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp4', 'p_seen00']
p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp4 ? (p_ttl) : (p_last_ttl01)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp4', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp4 ? (0) : (p_ttl_change01)
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp4', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'last_ttl', 'ttl_change', 'seen'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp4 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp4 ? (1) : (p_seen00);
RAW p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01);
RAW p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00);
RAW p__br_tmp4 = p_seen00==0; p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp4 = p_seen00==0; p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'last_ttl': {'read': <dependencyGraph.Statement object at 0x7f10bcd405b0>, 'write': <dependencyGraph.Statement object at 0x7f10bcd404f0>}, 'ttl_change': {'read': <dependencyGraph.Statement object at 0x7f10bcd40580>, 'write': <dependencyGraph.Statement object at 0x7f10bcd40400>}, 'seen': {'read': <dependencyGraph.Statement object at 0x7f10bcd40160>, 'write': <dependencyGraph.Statement object at 0x7f10bcd401f0>}}
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7f10bcd405b0>, 'write': <dependencyGraph.Statement object at 0x7f10bcd404f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7f10bcd40580>, 'write': <dependencyGraph.Statement object at 0x7f10bcd40400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  seen
{'read': <dependencyGraph.Statement object at 0x7f10bcd40160>, 'write': <dependencyGraph.Statement object at 0x7f10bcd401f0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp4 = p_seen00==0 stmts len 1
p__br_tmp4 = p_seen00==0;
v p_seen01 = p__br_tmp4 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp4 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f10bcd40c70>, <dependencyGraph.Codelet object at 0x7f10bcd40df0>, <dependencyGraph.Codelet object at 0x7f10bcd40bb0>, <dependencyGraph.Codelet object at 0x7f10bcd40d90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp4 = p_seen00==0;
p_seen01 = p__br_tmp4 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f10bcd40df0>, <dependencyGraph.Codelet object at 0x7f10bcd40bb0>, <dependencyGraph.Codelet object at 0x7f10bcd40c70>}
total number of nodes created:  4
state vars {'last_ttl', 'ttl_change', 'seen'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp3'}
elements in v_outputs:  {'p__br_tmp3'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp3'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp3', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp4', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
p__br_tmp3  not in state vars
 statement:  p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp3'}
   - createing a node for flank  p__br_tmp3
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p__br_tmp4', 'p_seen00'}
p_seen00  is read flank
elements in v_outputs:  {'p__br_tmp4', 'p_seen00'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp4'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp4 = p_seen00==0
2   p_seen01 = p__br_tmp4 ? (1) : (p_seen00)
3   seen = p_seen01
p__br_tmp4  not in state vars
 statement:  p__br_tmp4 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp4 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp4', 'p_seen00']
 state vars:  ['seen']
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p__br_tmp4', 'p_seen00'}
   - createing a node for flank  p_seen00
   - createing a node for flank  p__br_tmp4
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_9_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_9_out
Stored read, write flank variables
{'p_ttl_change02', 'p_last_ttl02', 'p_ttl_change00', 'p_seen00', 'p_last_ttl00', 'p_seen01'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp4 = p_seen00==0 p_seen01 = p__br_tmp4 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp4 = p_seen00==0 p_seen01 = p__br_tmp4 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp4 = p_seen00==0 p_seen01 = p__br_tmp4 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp4 = p_seen00==0 p_seen01 = p__br_tmp4 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp4 = p_seen00==0 p_seen01 = p__br_tmp4 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['p_ttl_change02', 'p_ttl_change01', 'ttl_change', 'p_ttl_change00']
 node inputs:  ['ttl_change', 'p__br_tmp4', 'p__br_tmp3']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp4', 'p__br_tmp3']
redundant outputs ['p_last_ttl01', 'p_last_ttl02', 'p_last_ttl00']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change02', 'p_ttl_change01', 'p_ttl_change00']
state_var ['ttl_change']
     | merged inputs:  ['p__br_tmp4', 'p_ttl', 'ttl_change', 'p_seen00']
		| merged state vars:  {'last_ttl', 'ttl_change'}
		| merged stateless vars:  ['p__br_tmp4', 'p_ttl', 'p_seen00']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp4', 'p_ttl', 'p_seen00', 'ttl_change', 'p__br_tmp4', 'p__br_tmp3']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['last_ttl', 'p__br_tmp3']
 node inputs:  ['last_ttl', 'p__br_tmp4', 'p_ttl', 'p_seen00']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp4', 'ttl_change', 'p__br_tmp3'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp4', 'p_ttl', 'p_seen00', 'ttl_change', 'p__br_tmp4', 'p__br_tmp3']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp4', 'p__br_tmp3']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p__br_tmp4', 'p_ttl', 'p_seen00']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp4', 'p__br_tmp3']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['p_ttl', 'last_ttl']
		| merged state vars:  {'last_ttl', 'seen'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen01', 'p_seen00']
 | state_pkt_fields of component b:  ['p_last_ttl02', 'p_last_ttl00']
merge component: component is ----  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f10bcd405b0>, <dependencyGraph.Statement object at 0x7f10bcd40100>, <dependencyGraph.Statement object at 0x7f10bcd40520>, <dependencyGraph.Statement object at 0x7f10bcd40370>, <dependencyGraph.Statement object at 0x7f10bcd404f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp4', 'p__br_tmp3']
redundant outputs ['p_last_ttl01', 'p_last_ttl02', 'p_seen00', 'p_last_ttl00', 'p_seen01']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['p__br_tmp4', 'last_ttl', 'p__br_tmp3', 'seen']
new component state_pkt_fields:  ['p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_9_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_9_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_9_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p__br_tmp4', 'seen', 'p_seen00']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp4', 'p_ttl', 'last_ttl', 'p_seen00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p__br_tmp4', 'seen', 'p_seen00']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp4', 'p_ttl', 'ttl_change', 'p_seen00', 'last_ttl', 'p__br_tmp3'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp3 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp4 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp4 = p_seen00==0; p_seen01 = p__br_tmp4 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p__br_tmp4', 'p_ttl', 'p_seen00']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp3 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp3 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp4 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p__br_tmp4', 'p_ttl', 'p_seen00']
 problematic state vars:  ['last_ttl']
preprocessor time:
running mutation 10
directory: /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change, program name: dns_ttl_change_equivalent_10. Grammar: nested_ifs. Continue?
------------------------------
Preprocessing done. Continuing
p_last_ttl00 = last_ttl;

lhs p_last_ttl00 rhs last_ttl
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl00 = last_ttl;

 is_read_flank: processing rhs_vars =  ['last_ttl']
read flank
p_ttl_change00 = ttl_change;

lhs p_ttl_change00 rhs ttl_change
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change00 = ttl_change;

 is_read_flank: processing rhs_vars =  ['ttl_change']
read flank
p_seen00 = seen;

lhs p_seen00 rhs seen
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_seen00 = seen;

 is_read_flank: processing rhs_vars =  ['seen']
read flank
p_id0 = p_rdata;

lhs p_id0 rhs p_rdata
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_id0 = p_rdata;

 is_read_flank: processing rhs_vars =  ['p_rdata']
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

lhs p__br_tmp5 rhs (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);

 is_read_flank: processing rhs_vars =  ['p_seen00', 'p_last_ttl00', 'p_ttl']
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

lhs p_last_ttl01 rhs p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

lhs p_ttl_change01 rhs p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp5', 'p_ttl_change00', 'p_ttl_change00']
p__br_tmp6 = p_seen00==0;

lhs p__br_tmp6 rhs p_seen00==0
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p__br_tmp6 = p_seen00==0;

 is_read_flank: processing rhs_vars =  ['p_seen00']
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

lhs p_seen01 rhs p__br_tmp6 ? (1) : (p_seen00)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_seen01 = p__br_tmp6 ? (1) : (p_seen00);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_seen00']
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

lhs p_last_ttl02 rhs p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

lhs p_ttl_change02 rhs p__br_tmp6 ? (0) : (p_ttl_change01)
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);

 is_read_flank: processing rhs_vars =  ['p__br_tmp6', 'p_ttl_change01']
last_ttl = p_last_ttl02;

lhs last_ttl rhs p_last_ttl02
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  last_ttl = p_last_ttl02;

 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
write flank
ttl_change = p_ttl_change02;

lhs ttl_change rhs p_ttl_change02
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  ttl_change = p_ttl_change02;

 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
write flank
seen = p_seen01;

lhs seen rhs p_seen01
state_vars {'ttl_change', 'seen', 'last_ttl'}
read/write flanks: processing line  seen = p_seen01;

 is_read_flank: processing rhs_vars =  ['p_seen01']
write flank
finding dependencies
RAW p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_last_ttl00 = last_ttl; p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_seen00 = seen; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
RAW p_seen00 = seen; p__br_tmp6 = p_seen00==0;
RAW p_seen00 = seen; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
RAW p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
RAW p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
RAW p__br_tmp6 = p_seen00==0; p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
RAW p__br_tmp6 = p_seen00==0; p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
RAW p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
RAW p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
RAW p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
read_write_flanks {'ttl_change': {'read': <dependencyGraph.Statement object at 0x7f3dc69c5580>, 'write': <dependencyGraph.Statement object at 0x7f3dc69c5400>}, 'seen': {'read': <dependencyGraph.Statement object at 0x7f3dc69c5160>, 'write': <dependencyGraph.Statement object at 0x7f3dc69c51f0>}, 'last_ttl': {'read': <dependencyGraph.Statement object at 0x7f3dc69c55b0>, 'write': <dependencyGraph.Statement object at 0x7f3dc69c54f0>}}
var:  ttl_change
{'read': <dependencyGraph.Statement object at 0x7f3dc69c5580>, 'write': <dependencyGraph.Statement object at 0x7f3dc69c5400>}
state_var  ttl_change
read_flank p_ttl_change00 = ttl_change
write_flank ttl_change = p_ttl_change02
var:  seen
{'read': <dependencyGraph.Statement object at 0x7f3dc69c5160>, 'write': <dependencyGraph.Statement object at 0x7f3dc69c51f0>}
state_var  seen
read_flank p_seen00 = seen
write_flank seen = p_seen01
var:  last_ttl
{'read': <dependencyGraph.Statement object at 0x7f3dc69c55b0>, 'write': <dependencyGraph.Statement object at 0x7f3dc69c54f0>}
state_var  last_ttl
read_flank p_last_ttl00 = last_ttl
write_flank last_ttl = p_last_ttl02
total number of nodes created:  14
SCC 0
v p_ttl_change00 = ttl_change stmts len 1
p_ttl_change00 = ttl_change;
v p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) stmts len 1
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
v p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) stmts len 1
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
v ttl_change = p_ttl_change02 stmts len 1
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
SCC 1
v p_last_ttl00 = last_ttl stmts len 1
p_last_ttl00 = last_ttl;
v p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) stmts len 1
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
v p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) stmts len 1
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
v p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) stmts len 1
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
v last_ttl = p_last_ttl02 stmts len 1
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
SCC 2
v p_seen00 = seen stmts len 1
p_seen00 = seen;
v p__br_tmp6 = p_seen00==0 stmts len 1
p__br_tmp6 = p_seen00==0;
v p_seen01 = p__br_tmp6 ? (1) : (p_seen00) stmts len 1
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
v seen = p_seen01 stmts len 1
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
SCC 3
v p_id0 = p_rdata stmts len 1
p_id0 = p_rdata;
SCC graph nodes
[<dependencyGraph.Codelet object at 0x7f3dc69c5c70>, <dependencyGraph.Codelet object at 0x7f3dc69c5df0>, <dependencyGraph.Codelet object at 0x7f3dc69c5bb0>, <dependencyGraph.Codelet object at 0x7f3dc69c5d90>]
p_ttl_change00 = ttl_change;
p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00);
p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01);
ttl_change = p_ttl_change02;
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
stateful
p_last_ttl00 = last_ttl;
p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl);
p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00);
p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01);
last_ttl = p_last_ttl02;
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
stateful
p_seen00 = seen;
p__br_tmp6 = p_seen00==0;
p_seen01 = p__br_tmp6 ? (1) : (p_seen00);
seen = p_seen01;
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
stateful
p_id0 = p_rdata;
SCC graph stateful nodes {<dependencyGraph.Codelet object at 0x7f3dc69c5df0>, <dependencyGraph.Codelet object at 0x7f3dc69c5bb0>, <dependencyGraph.Codelet object at 0x7f3dc69c5c70>}
total number of nodes created:  4
state vars {'ttl_change', 'seen', 'last_ttl'}
----calling split_SCC_graph---
 ---- split_SCC_graph ----- 
 -------------- v_outputs:  set()
everything fits within a stateful ALU (no outputs). No need to do anything.
 -------------- v_outputs:  {'p__br_tmp5'}
elements in v_outputs:  {'p__br_tmp5'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['last_ttl']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp5'}
codelet statements in order: 
0   p_last_ttl00 = last_ttl
1   p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
2   p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
3   p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
4   last_ttl = p_last_ttl02
p_last_ttl00  not in state vars
 statement:  p_last_ttl00 = last_ttl
 rhs_vars:  ['last_ttl']
 state vars:  ['last_ttl']
p__br_tmp5  not in state vars
 statement:  p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl)
 rhs_vars:  ['p_seen00', 'p_last_ttl00', 'p_ttl']
 state vars:  ['last_ttl']
p_last_ttl02  not in state vars
 statement:  p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01)
 rhs_vars:  ['p__br_tmp6', 'p_ttl', 'p_last_ttl01']
 state vars:  ['last_ttl']
p_last_ttl01  not in state vars
 statement:  p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00)
 rhs_vars:  ['p__br_tmp5', 'p_ttl', 'p_last_ttl00']
 state vars:  ['last_ttl']
size of SCC graph pre-duplicate:  4
flanks:  {'p__br_tmp5'}
   - createing a node for flank  p__br_tmp5
size of SCC graph post-duplicate:  4
 -------------- v_outputs:  {'p__br_tmp6', 'p_seen00'}
p_seen00  is read flank
elements in v_outputs:  {'p__br_tmp6', 'p_seen00'}
Number of state variables:  1
NUmber of stateful registers:  2
State variables:  ['seen']
Case 2(a) triggered. 
all fills found. they are:  {'p__br_tmp6'}
codelet statements in order: 
0   p_seen00 = seen
1   p__br_tmp6 = p_seen00==0
2   p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
3   seen = p_seen01
p__br_tmp6  not in state vars
 statement:  p__br_tmp6 = p_seen00==0
 rhs_vars:  ['p_seen00']
 state vars:  ['seen']
p_seen01  not in state vars
 statement:  p_seen01 = p__br_tmp6 ? (1) : (p_seen00)
 rhs_vars:  ['p__br_tmp6', 'p_seen00']
 state vars:  ['seen']
p_seen00  not in state vars
 statement:  p_seen00 = seen
 rhs_vars:  ['seen']
 state vars:  ['seen']
size of SCC graph pre-duplicate:  4
output  p_seen00    read_flanks:  ['p_seen00']   write_flanks:  []
flanks:  {'p__br_tmp6', 'p_seen00'}
   - createing a node for flank  p_seen00
   - createing a node for flank  p__br_tmp6
size of SCC graph post-duplicate:  5
number of SCC nodes post splitting:  5
total number of nodes created:  5
Output directory /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_10_out could not be created
Synthesizer
output dir /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_10_out
Stored read, write flank variables
{'p_ttl_change00', 'p_last_ttl00', 'p_ttl_change02', 'p_seen01', 'p_last_ttl02', 'p_seen00'}
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
-------------------------------------- stateful codelet vars :  ['last_ttl'] --------------***
compute_scc_graph: StatefulComponent( comp_0 ): state vars:  ['last_ttl']
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_1 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
-------------------------------------- stateful codelet vars :  ['seen'] --------------***
compute_scc_graph: StatefulComponent( comp_2 ): state vars:  ['seen']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
-------------------------------------- stateful codelet vars :  ['ttl_change'] --------------***
compute_scc_graph: StatefulComponent( comp_3 ): state vars:  ['ttl_change']
codelet  p_ttl_change00 = ttl_change p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00) p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01) ttl_change = p_ttl_change02  is stateful
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
codelet  p_last_ttl00 = last_ttl p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl) p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00) p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01) last_ttl = p_last_ttl02  is stateful
codelet  p_seen00 = seen p__br_tmp6 = p_seen00==0 p_seen01 = p__br_tmp6 ? (1) : (p_seen00) seen = p_seen01  is stateful
number of nodes on SCC_GRAPH:  5
number of nodes in comp_graph:  5
 * recursive_merge strategy: nodes ordered  ['p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;', 'p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;', 'p_id0 = p_rdata;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;', 'p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;']
 * recursive_merge: node ::  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 node outputs:  ['p_ttl_change00', 'p_ttl_change01', 'p_ttl_change02', 'ttl_change']
 node inputs:  ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_last_ttl00', 'p_last_ttl02', 'p_last_ttl01']
state_var ['last_ttl']
adj_inputs []
redundant outputs ['p_ttl_change00', 'p_ttl_change01', 'p_ttl_change02']
state_var ['ttl_change']
     | merged inputs:  ['p__br_tmp6', 'ttl_change', 'p_ttl', 'p_seen00']
		| merged state vars:  {'ttl_change', 'last_ttl'}
		| merged stateless vars:  ['p__br_tmp6', 'p_ttl', 'p_seen00']
 	| cannot merge: too many inputs.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00', 'ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs []
redundant outputs []
state_var ['ttl_change']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
 * recursive_merge: finished processing  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
 * recursive_merge: node ::  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 node outputs:  ['last_ttl', 'p__br_tmp5']
 node inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp5', 'ttl_change', 'p__br_tmp6'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00', 'ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['last_ttl']
    ~ merge_candidate: predecessor packing condition not met.
     | not a merge candidate.
  - recursive_merge: looking at preds of  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
     |  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
adj_inputs ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
redundant outputs ['p_seen01']
state_var ['seen']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs []
state_var ['last_ttl']
		~ merge_candidate: cannot merge a and b because too many output variables.
     | merged inputs:  ['last_ttl', 'p_ttl']
		| merged state vars:  {'seen', 'last_ttl'}
		| merged stateless vars:  ['p_ttl']
		| merge_candidate: Can try merging.
try_merge: trying to merge components: 
 | a:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 | b:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 | state_pkt_fields of component a:  ['p_seen01', 'p_seen00']
 | state_pkt_fields of component b:  ['p_last_ttl02', 'p_last_ttl00']
merge component: component is ----  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ********************** adding statements from component  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;  with *************************
[<dependencyGraph.Statement object at 0x7f3dc69c55b0>, <dependencyGraph.Statement object at 0x7f3dc69c5100>, <dependencyGraph.Statement object at 0x7f3dc69c5520>, <dependencyGraph.Statement object at 0x7f3dc69c5370>, <dependencyGraph.Statement object at 0x7f3dc69c54f0>]
 --my stateful vars:  ['seen']
 --their stateful vars:  ['last_ttl']
adj_inputs ['ttl_change', 'p__br_tmp5', 'p__br_tmp6']
redundant outputs ['p_last_ttl00', 'p_last_ttl01', 'p_last_ttl02', 'p_seen01', 'p_seen00']
state_var ['seen', 'last_ttl']
resultant component: 
p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01; p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
new component inputs:  ['seen', 'p_ttl', 'last_ttl']
new component outputs:  ['p__br_tmp6', 'seen', 'last_ttl', 'p__br_tmp5']
new component state_pkt_fields:  ['p_seen01', 'p_seen00', 'p_last_ttl02', 'p_last_ttl00']
-------------- Merging... -------------
~~~~~~~~~~set_alu_inputs:  ['seen', 'last_ttl', 'p_ttl']
 ~~~| state var:  ['seen', 'last_ttl']
salu_inputs {'metadata_lo': 'p_ttl', 'metadata_hi': 0, 'register_lo': 'seen', 'register_hi': 'last_ttl'}
sketch /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_10_out/try_merge_query_0_stateful.sk > /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_10_out/try_merge_query_0_stateful.sk.out
running sketch for stateful
sketch_filename /home/xiangyug/ruijief/benchmarks/Domino_mutations/dns_ttl_change/dns_ttl_change_equivalent_10_out/try_merge_query_0_stateful.sk
return code 1
failed
---------- Merge failure. ---------
   | synthesis query failed. Not merging.
   | number of nodes in comp_graph:  5
 * recursive_merge: finished processing  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 * recursive_merge: node ::  p_id0 = p_rdata;
 node outputs:  ['p_id0']
 node inputs:  ['p_rdata']
 exclude_read_write_flanks: successor inputs:  set()
 exclude_read_write_flanks: filtered outputs (temp filtered):  []
 * recursive_merge: finished processing  p_id0 = p_rdata;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p__br_tmp6', 'seen', 'p_seen00']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p_ttl', 'p__br_tmp6', 'last_ttl', 'p_seen00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 * recursive_merge: node ::  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 node outputs:  ['p__br_tmp6', 'seen', 'p_seen00']
 node inputs:  ['seen']
 exclude_read_write_flanks: successor inputs:  {'p__br_tmp6', 'ttl_change', 'last_ttl', 'p__br_tmp5', 'p_ttl', 'p_seen00'}
 exclude_read_write_flanks: filtered outputs (temp filtered):  ['p_seen00']
 * recursive_merge: finished processing  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
 ----------------- iteratively folding node. folding_idx =  0
 is_read_flank: processing rhs_vars =  ['ttl_change']
 is_read_flank: processing rhs_vars =  ['p_ttl_change02']
 is_read_flank: processing rhs_vars =  ['last_ttl']
 is_read_flank: processing rhs_vars =  ['p_last_ttl02']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
 is_read_flank: processing rhs_vars =  ['seen']
 is_read_flank: processing rhs_vars =  ['p_seen01']
Principal Outputs:  {'p_id0'}
{'p_id0'}
u:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_ttl_change00 = ttl_change; p_ttl_change01 = p__br_tmp5 ? (1+p_ttl_change00) : (p_ttl_change00); p_ttl_change02 = p__br_tmp6 ? (0) : (p_ttl_change01); ttl_change = p_ttl_change02;
u:  p_seen00 = seen; p__br_tmp6 = p_seen00==0; p_seen01 = p__br_tmp6 ? (1) : (p_seen00); seen = p_seen01;
v:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
~~~~~~~~~~set_alu_inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 ~~~| state var:  ['last_ttl']
Error: Cannot have > 2 metadata fields in a stateful ALU. Component:  p_last_ttl00 = last_ttl; p__br_tmp5 = (!(p_seen00==0))&&(p_last_ttl00!=p_ttl); p_last_ttl01 = p__br_tmp5 ? (p_ttl) : (p_last_ttl00); p_last_ttl02 = p__br_tmp6 ? (p_ttl) : (p_last_ttl01); last_ttl = p_last_ttl02;
 problematic inputs:  ['last_ttl', 'p_ttl', 'p__br_tmp6', 'p_seen00']
 problematic state vars:  ['last_ttl']
preprocessor time:
