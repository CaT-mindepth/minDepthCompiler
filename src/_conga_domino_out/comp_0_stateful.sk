generator int C() { return ??; }

generator int Opt(int op1) {
  bit enable = ??(1);
  if (enable != 0) {
    return 0;
  }
  else {
    return op1;
  }
}

generator int Mux2(int op1, int op2) {
  int choice = ??(1);
  if (choice == 0) {
    return op1;
  }
  else {
    return op2;
  }
}

generator int Mux3(int op1, int op2, int op3) {
  int choice = ??(2);
  if (choice == 0) {
    return op1;
  }
  if (choice == 1) {
    return op2;
  }
  else {
    return op3;
  }
}

generator int Mux4(int op1, int op2, int op3, int op4) {
  int choice = ??(2);
  if (choice == 0) {
    return op1;
  }
  if (choice == 1) {
    return op2;
  }
  if (choice == 2) {
    return op3;
  }
  else {
    return op4;
  }
}

generator int arith_op(int o1, int o2) {
  int opcode = ??(1);
  if (opcode == 0) {
    return o1 + o2;
  } 
  else {
    return o1 - o2;
  }
}

generator bit rel_op(int o1, int o2) {
  int opcode = ??(2);
  if (opcode == 0) {
    return o1 != o2;
  }
  if (opcode == 1) {
    return o1 < o2;
  }
  if (opcode == 2) {
    return o1 > o2;
  }
  else {
    return o1 == o2;
  }
        //return {| o1 ( == | != | > | >= | < | <= ) o2 |};
}

bit bool_op(int opcode, bit o1, bit o2) {
        if (opcode == 0) {
                return 0;
        }
        if (opcode == 1) {
                return !(o1 | o2);
        }
  if (opcode == 2) {
    return (!o1) & o2;
  }
  if (opcode == 3) {
    return !o1;
  }
  if (opcode == 4) {
    return o1 & (!o2);
  }
  if (opcode == 5) {
    return !o2;
  }
  if (opcode == 6) {
    // used to be XOR; switched to AND because Tofino compiler doesn't accept it
    return o1 & o2;
  }
  if (opcode == 7) {
    return !(o1 & o2);
  }
  if (opcode == 8) {
    return o1 & o2;
  }
  if (opcode == 9) {
    // This used to be XOR; it's been switched to AND because the Tofino compiler doesn't accept it (issue #20).
    return !(o1 & o2);
  }
  if (opcode == 10) {
    return o2;
  }
  if (opcode == 11) {
    return (!o1) | o2;
  }
  if (opcode == 12) {
    return o1;
  }
  if (opcode == 13) {
    return o1 | (!o2);
  }
  if (opcode == 14) {
    return o1 | o2;
  }
        else {
                return 1;
        }
}
int salu(int state_0, int state_1, int pkt_1, int pkt_2) {
int old_state_0 = state_0;
int old_state_1 = state_1;
if (rel_op(Mux3(state_0, state_1, 0) + Mux3(pkt_1, pkt_2, 0) - Mux3(pkt_1, pkt_2, 0), C())) {
 if (rel_op(Mux3(state_0, state_1, 0) + Mux3(pkt_1, pkt_2, 0) - Mux3(pkt_1, pkt_2, 0), C())) {
  state_0 = Opt(state_0) + arith_op(Mux3(pkt_1, pkt_2, C()),  Mux3(pkt_1, pkt_2, C()));
  state_1 = Opt(state_1) + arith_op(Mux3(pkt_1, pkt_2, C()),  Mux3(pkt_1, pkt_2, C()));
 } else {
  state_0 = Opt(state_0) + arith_op(Mux3(pkt_1, pkt_2, C()),  Mux3(pkt_1, pkt_2, C()));
  state_1 = Opt(state_1) + arith_op(Mux3(pkt_1, pkt_2, C()),  Mux3(pkt_1, pkt_2, C()));
 }
} else if (rel_op(Mux3(state_0, state_1, 0) + Mux3(pkt_1, pkt_2, 0) - Mux3(pkt_1, pkt_2, 0), C())) {
 if (rel_op(Mux3(state_0, state_1, 0) + Mux3(pkt_1, pkt_2, 0) - Mux3(pkt_1, pkt_2, 0), C())) {
  state_0 = Opt(state_0) + arith_op(Mux3(pkt_1, pkt_2, C()),  Mux3(pkt_1, pkt_2, C()));
  state_1 = Opt(state_1) + arith_op(Mux3(pkt_1, pkt_2, C()),  Mux3(pkt_1, pkt_2, C()));
 } else {
  state_0 = Opt(state_0) + arith_op(Mux3(pkt_1, pkt_2, C()),  Mux3(pkt_1, pkt_2, C()));
  state_1 = Opt(state_1) + arith_op(Mux3(pkt_1, pkt_2, C()),  Mux3(pkt_1, pkt_2, C()));
 }
}

return Mux4(old_state_0, old_state_1, state_0, state_1);
}
int comp_0(int best_path, int p_path_id0, int best_path_util, int p_util0){
	int _out;
	bit p_br_tmp1;
	int p_best_path_util_p_best_path_util_idx0_2;
	bit p_br_tmp0;
	int p_best_path_util_p_best_path_util_idx0_4;
	int p_best_path_util_p_best_path_util_idx0_0;
	int p_best_path_p_best_path_idx0_0;
	int p_best_path_p_best_path_idx0_2;
	p_best_path_util_p_best_path_util_idx0_0 = best_path_util;
	p_br_tmp0 = (p_util0 < p_best_path_util_p_best_path_util_idx0_0);
	p_best_path_util_p_best_path_util_idx0_2 = p_br_tmp0 ? p_util0 : p_best_path_util_p_best_path_util_idx0_0;
	p_best_path_p_best_path_idx0_0 = best_path;
	p_best_path_p_best_path_idx0_2 = p_br_tmp0 ? p_path_id0 : p_best_path_p_best_path_idx0_0;
	best_path = p_best_path_p_best_path_idx0_2;
	p_br_tmp1 = !(p_util0 < p_best_path_util_p_best_path_util_idx0_0) && (p_path_id0 == p_best_path_p_best_path_idx0_2);
	p_best_path_util_p_best_path_util_idx0_4 = p_br_tmp1 ? p_util0 : p_best_path_util_p_best_path_util_idx0_2;
	best_path_util = p_best_path_util_p_best_path_util_idx0_4;
	_out = best_path;
	return _out;
}

harness void sketch(int best_path, int p_path_id0, int best_path_util, int p_util0) {
	 int impl = salu(best_path, best_path_util, p_path_id0, p_util0);
	int spec = comp_0(best_path, p_path_id0, best_path_util, p_util0);
	assert(impl == spec);
}
