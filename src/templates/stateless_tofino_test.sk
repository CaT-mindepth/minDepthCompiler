int iteop = 14;

struct tempVar {
	int id;
	int temp;
}

generator int arith_op(int o1, int o2) {
  int opcode = ??(1);
  if (opcode == 0) {
    return o1 + o2;
  } else {
    assert(opcode == 1);
    return o1 - o2;
  }
}

generator bit relop(int o1, int o2) {
	return {| o1 ( == | != | > | >= | < | <= ) o2 |};
}

generator bit bool_op(bit o1, bit o2) {
	int opcode = ??(2);
	if (opcode == 0) {
		return o1 & o2;
	}
	else if (opcode == 1) {
		return o1 | o2;
	}
	else {
		return ~o1;
	}
}

generator int C() { return ??; }

generator int Opt(int op1) {
  bit enable = ??(1);
  if (! enable) return 0;

  return op1;
}

generator int Mux2(int op1, int op2) {
  int choice = ??(1);
  if (choice == 0) return op1;
  else if (choice == 1) return op2;
}

generator int Mux3(int op1, int op2, int op3) {
  int choice = ??(2);
  if (choice == 0) return op1;
  else if (choice == 1) return op2;
  else if (choice == 2) return op3;
  else assert(false);
}

generator int Mux4(int op1, int op2, int op3, int op4) {
  int choice = ??(2);
  if (choice == 0) return op1;
  else if (choice == 1) return op2;
  else if (choice == 2) return op3;
  else return op4;
}

generator int relopcodes() {
	return {|6 | 8 | 10 | 12|};
}

int alu(int op, int o1, int o2) {
	if (op == 0) {
		return {|?? | -??|};
	}
	if (op == 2) {
		return o1 + o2;
	}
	if (op == 4) {
		return o2 - o1;
	}
}

bit alu_rel(int relop, int o1, int o2) {
	if (relop == 6) {
		return o1 != o2;
	}
	if (relop == 8) {
		return o1 == o2;
	}
	if (relop == 10) {
		return o1 >= o2;
	}
	if (relop == 12) {
		return o1 < o2;
	}
}

bit alu_bool(int op, bit o1, bit o2) {
	if (op == 16) {
		return o1 | o2;
	}
	if (op == 18) {
		return o1 & o2;
	}
}

int stateful_compute_alu(int op, int o1, int o2) {
	if (op == 0) {
		return o1 + o2;
	}
	else if (op == 1) {
		return o1 - o2;
	}
	else if (op == 2) {
		return o2 - o1;
	}
	else if (op == 3) {
		return o2;
	}
	else if (op == 4) {
		return o1;
	}
	else if (op == 5) {
		return 0;
	}
	else {
		return 1;
	}
}

// If stateless_flag is true register_lo and register_hi are constants

int salu(int metadata_lo, int metadata_hi, int register_lo, int register_hi, bit stateless_flag) {
    int original_lo = register_lo;
    int original_hi = register_hi;
    
    // compute_alu(A, B), where A can be metadata or constant
    // where B can be register or constant

    // Model computation ALUs from Tofino salu.pdf
	int update_hi_1_value, update_hi_2_value, update_lo_1_value, update_lo_2_value;
	if (stateless_flag) {
		update_hi_1_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), C());
		update_hi_2_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), C());
		update_lo_1_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), C());
		update_lo_2_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), C());
	}
	else {
		update_hi_1_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), Mux3(register_lo, register_hi, C()));
		update_hi_2_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), Mux3(register_lo, register_hi, C()));
		update_lo_1_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), Mux3(register_lo, register_hi, C()));
		update_lo_2_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), Mux3(register_lo, register_hi, C()));
	}
    
    // Comparison unit
    // NOTE: rel_op doesn't support >-, <= but it should be enough because
    // bool_op (used to compute the ALU predicates) has support for ~.
	// TODO: Confirm : >=, <= supported accd to stateful ALU pdf
	// +- metadata +- register + C <relop> 0

	bit condition_hi, condition_lo;

	if (stateless_flag) {
		condition_hi = relop(arith_op(arith_op(0, Mux3(metadata_lo, metadata_hi, 0)),
                                    C()),
                            0);
   		condition_lo = relop(arith_op(arith_op(0, Mux3(metadata_lo, metadata_hi, 0)),
                                    C()),
                            0);
	}
	else {
		condition_hi = relop(arith_op(arith_op(0, Mux3(metadata_lo, metadata_hi, 0)),
                                    Mux3(register_lo, register_hi, 0)) + C(),
                            0);

   		condition_lo = relop(arith_op(arith_op(0, Mux3(metadata_lo, metadata_hi, 0)),
                                    Mux3(register_lo, register_hi, 0)) + C(),
                            0);
	}
    
    // ALU predicates
    bit update_hi_1_predicate = bool_op(condition_hi, condition_lo);
    bit update_hi_2_predicate = bool_op(condition_hi, condition_lo);
    bit update_lo_1_predicate = bool_op(condition_hi, condition_lo);
    bit update_lo_2_predicate = bool_op(condition_hi, condition_lo);


    // Actually run the ALUs (update register_lo, register_hi)
    if (update_hi_1_predicate && update_hi_2_predicate) {
    // TODO: Implement necessary code to compute bitwise OR using bit vectors.
    // Following line needs to be written as register_hi = update_hi_1_value | update_hi_2_value.
    // The bitwise OR of the two alu values. Sketch only supports bitwisse OR for
    // bit vectors not for ints. So we now leave this as assert(false) to catch
    // that certain benchmarks don't pass because of this.
        assert(false);
    } else if (update_hi_1_predicate && !update_hi_2_predicate) {
        register_hi = update_hi_1_value;
    } else if (!update_hi_1_predicate && update_hi_2_predicate) {
        register_hi = update_hi_2_value;
    } else {
        register_hi = register_hi;
    }

    if (update_lo_1_predicate && update_lo_2_predicate) {
    // TODO: Same as above.
        assert(false);
    } else if (update_lo_1_predicate && !update_lo_2_predicate) {
        register_lo = update_lo_1_value;
    } else if (!update_lo_1_predicate && update_lo_2_predicate) {
        register_lo = update_lo_2_value;
    } else {
        register_lo = register_lo;
    }

    int alu_lo = register_lo;
    int alu_hi = register_hi;

    // TODO: We can only update one metadata field, and we don't know at this point
    // which one will get updated. We would return simply one value from here and
    // let the output mux choose. To handle this, we would like to change all
    // stateful alus to return one single integer value and modify related Python
    // sketch generator scripts to accomodate this.
    int output_value = Mux4(original_lo, original_hi, alu_lo, alu_hi);
    return output_value;
}

int[2] salu1(int metadata_lo, int metadata_hi, int register_lo, int register_hi, bit stateless_flag) {
    int original_lo = register_lo;
    int original_hi = register_hi;
    
    // compute_alu(A, B), where A can be metadata or constant
    // where B can be register or constant

    // Model computation ALUs from Tofino salu.pdf
	int update_hi_1_value, update_hi_2_value, update_lo_1_value, update_lo_2_value;
	if (stateless_flag) {
		update_hi_1_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), C());
		update_hi_2_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), C());
		update_lo_1_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), C());
		update_lo_2_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), C());
	}
	else {
		update_hi_1_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), Mux3(register_lo, register_hi, C()));
		update_hi_2_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), Mux3(register_lo, register_hi, C()));
		update_lo_1_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), Mux3(register_lo, register_hi, C()));
		update_lo_2_value = stateful_compute_alu(??(3), Mux3(metadata_lo, metadata_hi, C()), Mux3(register_lo, register_hi, C()));
	}
    
    // Comparison unit
    // NOTE: rel_op doesn't support >-, <= but it should be enough because
    // bool_op (used to compute the ALU predicates) has support for ~.
	// TODO: Confirm : >=, <= supported accd to stateful ALU pdf
	// +- metadata +- register + C <relop> 0

	bit condition_hi, condition_lo;

	if (stateless_flag) {
		condition_hi = relop(arith_op(arith_op(0, Mux3(metadata_lo, metadata_hi, 0)),
                                    C()),
                            0);
   		condition_lo = relop(arith_op(arith_op(0, Mux3(metadata_lo, metadata_hi, 0)),
                                    C()),
                            0);
	}
	else {
		condition_hi = relop(arith_op(arith_op(0, Mux3(metadata_lo, metadata_hi, 0)),
                                    Mux3(register_lo, register_hi, 0)) + C(),
                            0);

   		condition_lo = relop(arith_op(arith_op(0, Mux3(metadata_lo, metadata_hi, 0)),
                                    Mux3(register_lo, register_hi, 0)) + C(),
                            0);
	}
    
    // ALU predicates
    bit update_hi_1_predicate = bool_op(condition_hi, condition_lo);
    bit update_hi_2_predicate = bool_op(condition_hi, condition_lo);
    bit update_lo_1_predicate = bool_op(condition_hi, condition_lo);
    bit update_lo_2_predicate = bool_op(condition_hi, condition_lo);


    // Actually run the ALUs (update register_lo, register_hi)
    if (update_hi_1_predicate && update_hi_2_predicate) {
    // TODO: Implement necessary code to compute bitwise OR using bit vectors.
    // Following line needs to be written as register_hi = update_hi_1_value | update_hi_2_value.
    // The bitwise OR of the two alu values. Sketch only supports bitwisse OR for
    // bit vectors not for ints. So we now leave this as assert(false) to catch
    // that certain benchmarks don't pass because of this.
        assert(false);
    } else if (update_hi_1_predicate && !update_hi_2_predicate) {
        register_hi = update_hi_1_value;
    } else if (!update_hi_1_predicate && update_hi_2_predicate) {
        register_hi = update_hi_2_value;
    } else {
        register_hi = register_hi;
    }

    if (update_lo_1_predicate && update_lo_2_predicate) {
    // TODO: Same as above.
        assert(false);
    } else if (update_lo_1_predicate && !update_lo_2_predicate) {
        register_lo = update_lo_1_value;
    } else if (!update_lo_1_predicate && update_lo_2_predicate) {
        register_lo = update_lo_2_value;
    } else {
        register_lo = register_lo;
    }

    int alu_lo = register_lo;
    int alu_hi = register_hi;

    // TODO: We can only update one metadata field, and we don't know at this point
    // which one will get updated. We would return simply one value from here and
    // let the output mux choose. To handle this, we would like to change all
    // stateful alus to return one single integer value and modify related Python
    // sketch generator scripts to accomodate this.
    int output_value = Mux4(original_lo, original_hi, alu_lo, alu_hi);
	int[2] out;
	out[0] = register_lo; // updated state variable
	out[1] = output_value;
    return out;
}

generator int expr(fun vars, fun bool_vars, int bnd) {
	assert bnd >= 0;
	int t = ??(3);
	if (t == 0) {
		return vars();
	}
	if (t == 1) {
		return ??;
	}
	if (t == 2) {
		return -??;
	}
	if (t == 3) {
		tempVar tmp = new tempVar();
		tmp.temp = salu(expr(vars, bool_vars, bnd-1), expr(vars, bool_vars, bnd-1), 0, 0, 1);
		return tmp.temp;
	}
	if (t == 4) {
		tempVar tmp = new tempVar();
		tmp.temp = alu(2, expr(vars, bool_vars, bnd-1), expr(vars, bool_vars, bnd-1));
		return tmp.temp;
	}
	else {
		tempVar tmp = new tempVar();
		tmp.temp = alu(4, expr(vars, bool_vars, bnd-1), expr(vars, bool_vars, bnd-1));
		return tmp.temp;
	}
}

generator bit bool_expr(fun vars, fun bool_vars, int bnd) {
	assert bnd >= 0;
	int t = ??(3);
	if (t == 0) {
		return bool_vars();
	}
	if (t == 1) {
		return {| 0 | 1 |};
	}
	if (t == 2) {
		return alu_rel(relopcodes(), expr(vars, bool_vars, bnd-1), expr(vars, bool_vars, bnd-1));
	}
	if (t == 3) {
		return alu_bool(18, bool_expr(vars, bool_vars, bnd-1), bool_expr(vars, bool_vars, bnd-1));
	}
	else {
		return alu_bool(16, bool_expr(vars, bool_vars, bnd-1), bool_expr(vars, bool_vars, bnd-1));
	}
}

int comp_0(int p_pkt1, int p_pkt2) {
	return p_pkt2 + 1;
	/*
	if (p_pkt1 == 10) {
		p_pkt2 = p_pkt2 + 1;
	}
	else {
		p_pkt2 = 0;
	}*/
}

int[2] sampling1_stateful(int count) {
	int[2] out;
	int p_count0 = count;
	bit p_br_tmp1 = !(p_count0 == 30 - 1);
	bit p_br_tmp0 = (p_count0 == 30 - 1);
	int p_count2 = p_br_tmp0 ? 0 : p_count0;
	int p_count3 = p_count2 + 1;
	int p_count4 = p_br_tmp1 ? p_count3 : p_count2;
	count = p_count4;
	out[0] = count;
	out[1] = p_br_tmp0;
	return out;
}

int sampling1_stateful2(int count) {
	int p_count0 = count;
	bit p_br_tmp1 = !(p_count0 == 30 - 1);
	bit p_br_tmp0 = (p_count0 == 30 - 1);
	int p_count2 = p_br_tmp0 ? 0 : p_count0;
	int p_count3 = p_count2 + 1;
	int p_count4 = p_br_tmp1 ? p_count3 : p_count2;
	count = p_count4;
	return p_br_tmp0; // NOTE: need to make sure count is updated accordingly: how to enforce this?
}

int[2] sampling1_stateful2_correct(int count) {
	int[2] ret;
	int p_count0 = count;
	bit p_br_tmp1 = !(p_count0 == 30 - 1);
	bit p_br_tmp0 = (p_count0 == 30 - 1);
	int p_count2 = p_br_tmp0 ? 0 : p_count0;
	int p_count3 = p_count2 + 1;
	int p_count4 = p_br_tmp1 ? p_count3 : p_count2;
	count = p_count4;
	ret[0] = count;
	ret[1] = p_br_tmp0;
	return ret; 
}

int sampling2(bit p_br_tmp0) {
	int p_sample4 = p_br_tmp0 ? 1 : 0;
	return p_sample4;
}

int[2] test(int count) {
	int[2] ret;
	bit br_tmp0 = (count == 2);
	int p_count0 = count + 1;
	ret[0] = p_count0;
	ret[1] = br_tmp0;
	return ret;
}
harness void sketch( bit p_br_tmp0, int count ) {
	generator int vars() {
		return {| count |};
	}
	/*generator int vars() {
		return {| 0 |};
	}*/
	generator bit bool_vars() {
		return {| 1 |};
	}
	/*generator bit bool_vars() {
		return {| p_br_tmp0 |};
	}*/

	//assert expr(vars, bool_vars, 1) == comp_0(p_pkt1, p_pkt2);
	//assert salu(0, 0, count, 0, 0) == sampling1_stateful1(count);
	//assert salu(0, 0, count, 0, 0) == sampling1_stateful2(count);
	//assert salu(p_br_tmp0, 0, 0, 0, 1) == sampling2(p_br_tmp0);
	//int [2] impl = salu1(0, 0, count, 0, 0);
	//int [2] spec = sampling1_stateful2_correct(count);
	//assert(impl[0] == spec[0] && impl[1] == spec[1]);

	int [2] impl = salu1(0, 0, count, 0, 0);
	int [2] spec = sampling1_stateful(count);
	assert(impl == spec);
}